{"ast":null,"code":"import { getAddress } from \"../address/index.js\";\nimport { keccak256, Signature, SigningKey } from \"../crypto/index.js\";\nimport { concat, decodeRlp, encodeRlp, getBytes, getBigInt, getNumber, hexlify, assert, assertArgument, toBeArray, zeroPadValue } from \"../utils/index.js\";\nimport { accessListify } from \"./accesslist.js\";\nimport { recoverAddress } from \"./address.js\";\nconst BN_0 = BigInt(0);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction handleAddress(value) {\n  if (value === \"0x\") {\n    return null;\n  }\n  return getAddress(value);\n}\nfunction handleAccessList(value, param) {\n  try {\n    return accessListify(value);\n  } catch (error) {\n    assertArgument(false, error.message, param, value);\n  }\n}\nfunction handleNumber(_value, param) {\n  if (_value === \"0x\") {\n    return 0;\n  }\n  return getNumber(_value, param);\n}\nfunction handleUint(_value, param) {\n  if (_value === \"0x\") {\n    return BN_0;\n  }\n  const value = getBigInt(_value, param);\n  assertArgument(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\n  return value;\n}\nfunction formatNumber(_value, name) {\n  const value = getBigInt(_value, \"value\");\n  const result = toBeArray(value);\n  assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);\n  return result;\n}\nfunction formatAccessList(value) {\n  return accessListify(value).map(set => [set.address, set.storageKeys]);\n}\nfunction _parseLegacy(data) {\n  const fields = decodeRlp(data);\n  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), \"invalid field count for legacy transaction\", \"data\", data);\n  const tx = {\n    type: 0,\n    nonce: handleNumber(fields[0], \"nonce\"),\n    gasPrice: handleUint(fields[1], \"gasPrice\"),\n    gasLimit: handleUint(fields[2], \"gasLimit\"),\n    to: handleAddress(fields[3]),\n    value: handleUint(fields[4], \"value\"),\n    data: hexlify(fields[5]),\n    chainId: BN_0\n  };\n  // Legacy unsigned transaction\n  if (fields.length === 6) {\n    return tx;\n  }\n  const v = handleUint(fields[6], \"v\");\n  const r = handleUint(fields[7], \"r\");\n  const s = handleUint(fields[8], \"s\");\n  if (r === BN_0 && s === BN_0) {\n    // EIP-155 unsigned transaction\n    tx.chainId = v;\n  } else {\n    // Compute the EIP-155 chain ID (or 0 for legacy)\n    let chainId = (v - BN_35) / BN_2;\n    if (chainId < BN_0) {\n      chainId = BN_0;\n    }\n    tx.chainId = chainId;\n    // Signed Legacy Transaction\n    assertArgument(chainId !== BN_0 || v === BN_27 || v === BN_28, \"non-canonical legacy v\", \"v\", fields[6]);\n    tx.signature = Signature.from({\n      r: zeroPadValue(fields[7], 32),\n      s: zeroPadValue(fields[8], 32),\n      v\n    });\n    tx.hash = keccak256(data);\n  }\n  return tx;\n}\nfunction _serializeLegacy(tx, sig) {\n  const fields = [formatNumber(tx.nonce || 0, \"nonce\"), formatNumber(tx.gasPrice || 0, \"gasPrice\"), formatNumber(tx.gasLimit || 0, \"gasLimit\"), tx.to != null ? getAddress(tx.to) : \"0x\", formatNumber(tx.value || 0, \"value\"), tx.data || \"0x\"];\n  let chainId = BN_0;\n  if (tx.chainId != BN_0) {\n    // A chainId was provided; if non-zero we'll use EIP-155\n    chainId = getBigInt(tx.chainId, \"tx.chainId\");\n    // We have a chainId in the tx and an EIP-155 v in the signature,\n    // make sure they agree with each other\n    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n  } else if (tx.signature) {\n    // No explicit chainId, but EIP-155 have a derived implicit chainId\n    const legacy = tx.signature.legacyChainId;\n    if (legacy != null) {\n      chainId = legacy;\n    }\n  }\n  // Requesting an unsigned transaction\n  if (!sig) {\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== BN_0) {\n      fields.push(toBeArray(chainId));\n      fields.push(\"0x\");\n      fields.push(\"0x\");\n    }\n    return encodeRlp(fields);\n  }\n  // @TODO: We should probably check that tx.signature, chainId, and sig\n  //        match but that logic could break existing code, so schedule\n  //        this for the next major bump.\n  // Compute the EIP-155 v\n  let v = BigInt(27 + sig.yParity);\n  if (chainId !== BN_0) {\n    v = Signature.getChainIdV(chainId, sig.v);\n  } else if (BigInt(sig.v) !== v) {\n    assertArgument(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n  }\n  // Add the signature\n  fields.push(toBeArray(v));\n  fields.push(toBeArray(sig.r));\n  fields.push(toBeArray(sig.s));\n  return encodeRlp(fields);\n}\nfunction _parseEipSignature(tx, fields) {\n  let yParity;\n  try {\n    yParity = handleNumber(fields[0], \"yParity\");\n    if (yParity !== 0 && yParity !== 1) {\n      throw new Error(\"bad yParity\");\n    }\n  } catch (error) {\n    assertArgument(false, \"invalid yParity\", \"yParity\", fields[0]);\n  }\n  const r = zeroPadValue(fields[1], 32);\n  const s = zeroPadValue(fields[2], 32);\n  const signature = Signature.from({\n    r,\n    s,\n    yParity\n  });\n  tx.signature = signature;\n}\nfunction _parseEip1559(data) {\n  const fields = decodeRlp(getBytes(data).slice(1));\n  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), \"invalid field count for transaction type: 2\", \"data\", hexlify(data));\n  const maxPriorityFeePerGas = handleUint(fields[2], \"maxPriorityFeePerGas\");\n  const maxFeePerGas = handleUint(fields[3], \"maxFeePerGas\");\n  const tx = {\n    type: 2,\n    chainId: handleUint(fields[0], \"chainId\"),\n    nonce: handleNumber(fields[1], \"nonce\"),\n    maxPriorityFeePerGas: maxPriorityFeePerGas,\n    maxFeePerGas: maxFeePerGas,\n    gasPrice: null,\n    gasLimit: handleUint(fields[4], \"gasLimit\"),\n    to: handleAddress(fields[5]),\n    value: handleUint(fields[6], \"value\"),\n    data: hexlify(fields[7]),\n    accessList: handleAccessList(fields[8], \"accessList\")\n  };\n  // Unsigned EIP-1559 Transaction\n  if (fields.length === 9) {\n    return tx;\n  }\n  tx.hash = keccak256(data);\n  _parseEipSignature(tx, fields.slice(9));\n  return tx;\n}\nfunction _serializeEip1559(tx, sig) {\n  const fields = [formatNumber(tx.chainId || 0, \"chainId\"), formatNumber(tx.nonce || 0, \"nonce\"), formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"), formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"), formatNumber(tx.gasLimit || 0, \"gasLimit\"), tx.to != null ? getAddress(tx.to) : \"0x\", formatNumber(tx.value || 0, \"value\"), tx.data || \"0x\", formatAccessList(tx.accessList || [])];\n  if (sig) {\n    fields.push(formatNumber(sig.yParity, \"yParity\"));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n  }\n  return concat([\"0x02\", encodeRlp(fields)]);\n}\nfunction _parseEip2930(data) {\n  const fields = decodeRlp(getBytes(data).slice(1));\n  assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), \"invalid field count for transaction type: 1\", \"data\", hexlify(data));\n  const tx = {\n    type: 1,\n    chainId: handleUint(fields[0], \"chainId\"),\n    nonce: handleNumber(fields[1], \"nonce\"),\n    gasPrice: handleUint(fields[2], \"gasPrice\"),\n    gasLimit: handleUint(fields[3], \"gasLimit\"),\n    to: handleAddress(fields[4]),\n    value: handleUint(fields[5], \"value\"),\n    data: hexlify(fields[6]),\n    accessList: handleAccessList(fields[7], \"accessList\")\n  };\n  // Unsigned EIP-2930 Transaction\n  if (fields.length === 8) {\n    return tx;\n  }\n  tx.hash = keccak256(data);\n  _parseEipSignature(tx, fields.slice(8));\n  return tx;\n}\nfunction _serializeEip2930(tx, sig) {\n  const fields = [formatNumber(tx.chainId || 0, \"chainId\"), formatNumber(tx.nonce || 0, \"nonce\"), formatNumber(tx.gasPrice || 0, \"gasPrice\"), formatNumber(tx.gasLimit || 0, \"gasLimit\"), tx.to != null ? getAddress(tx.to) : \"0x\", formatNumber(tx.value || 0, \"value\"), tx.data || \"0x\", formatAccessList(tx.accessList || [])];\n  if (sig) {\n    fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n  }\n  return concat([\"0x01\", encodeRlp(fields)]);\n}\n/**\n *  A **Transaction** describes an operation to be executed on\n *  Ethereum by an Externally Owned Account (EOA). It includes\n *  who (the [[to]] address), what (the [[data]]) and how much (the\n *  [[value]] in ether) the operation should entail.\n *\n *  @example:\n *    tx = new Transaction()\n *    //_result:\n *\n *    tx.data = \"0x1234\";\n *    //_result:\n */\nexport class Transaction {\n  #type;\n  #to;\n  #data;\n  #nonce;\n  #gasLimit;\n  #gasPrice;\n  #maxPriorityFeePerGas;\n  #maxFeePerGas;\n  #value;\n  #chainId;\n  #sig;\n  #accessList;\n  /**\n   *  The transaction type.\n   *\n   *  If null, the type will be automatically inferred based on\n   *  explicit properties.\n   */\n  get type() {\n    return this.#type;\n  }\n  set type(value) {\n    switch (value) {\n      case null:\n        this.#type = null;\n        break;\n      case 0:\n      case \"legacy\":\n        this.#type = 0;\n        break;\n      case 1:\n      case \"berlin\":\n      case \"eip-2930\":\n        this.#type = 1;\n        break;\n      case 2:\n      case \"london\":\n      case \"eip-1559\":\n        this.#type = 2;\n        break;\n      default:\n        assertArgument(false, \"unsupported transaction type\", \"type\", value);\n    }\n  }\n  /**\n   *  The name of the transaction type.\n   */\n  get typeName() {\n    switch (this.type) {\n      case 0:\n        return \"legacy\";\n      case 1:\n        return \"eip-2930\";\n      case 2:\n        return \"eip-1559\";\n    }\n    return null;\n  }\n  /**\n   *  The ``to`` address for the transaction or ``null`` if the\n   *  transaction is an ``init`` transaction.\n   */\n  get to() {\n    return this.#to;\n  }\n  set to(value) {\n    this.#to = value == null ? null : getAddress(value);\n  }\n  /**\n   *  The transaction nonce.\n   */\n  get nonce() {\n    return this.#nonce;\n  }\n  set nonce(value) {\n    this.#nonce = getNumber(value, \"value\");\n  }\n  /**\n   *  The gas limit.\n   */\n  get gasLimit() {\n    return this.#gasLimit;\n  }\n  set gasLimit(value) {\n    this.#gasLimit = getBigInt(value);\n  }\n  /**\n   *  The gas price.\n   *\n   *  On legacy networks this defines the fee that will be paid. On\n   *  EIP-1559 networks, this should be ``null``.\n   */\n  get gasPrice() {\n    const value = this.#gasPrice;\n    if (value == null && (this.type === 0 || this.type === 1)) {\n      return BN_0;\n    }\n    return value;\n  }\n  set gasPrice(value) {\n    this.#gasPrice = value == null ? null : getBigInt(value, \"gasPrice\");\n  }\n  /**\n   *  The maximum priority fee per unit of gas to pay. On legacy\n   *  networks this should be ``null``.\n   */\n  get maxPriorityFeePerGas() {\n    const value = this.#maxPriorityFeePerGas;\n    if (value == null) {\n      if (this.type === 2) {\n        return BN_0;\n      }\n      return null;\n    }\n    return value;\n  }\n  set maxPriorityFeePerGas(value) {\n    this.#maxPriorityFeePerGas = value == null ? null : getBigInt(value, \"maxPriorityFeePerGas\");\n  }\n  /**\n   *  The maximum total fee per unit of gas to pay. On legacy\n   *  networks this should be ``null``.\n   */\n  get maxFeePerGas() {\n    const value = this.#maxFeePerGas;\n    if (value == null) {\n      if (this.type === 2) {\n        return BN_0;\n      }\n      return null;\n    }\n    return value;\n  }\n  set maxFeePerGas(value) {\n    this.#maxFeePerGas = value == null ? null : getBigInt(value, \"maxFeePerGas\");\n  }\n  /**\n   *  The transaction data. For ``init`` transactions this is the\n   *  deployment code.\n   */\n  get data() {\n    return this.#data;\n  }\n  set data(value) {\n    this.#data = hexlify(value);\n  }\n  /**\n   *  The amount of ether (in wei) to send in this transactions.\n   */\n  get value() {\n    return this.#value;\n  }\n  set value(value) {\n    this.#value = getBigInt(value, \"value\");\n  }\n  /**\n   *  The chain ID this transaction is valid on.\n   */\n  get chainId() {\n    return this.#chainId;\n  }\n  set chainId(value) {\n    this.#chainId = getBigInt(value);\n  }\n  /**\n   *  If signed, the signature for this transaction.\n   */\n  get signature() {\n    return this.#sig || null;\n  }\n  set signature(value) {\n    this.#sig = value == null ? null : Signature.from(value);\n  }\n  /**\n   *  The access list.\n   *\n   *  An access list permits discounted (but pre-paid) access to\n   *  bytecode and state variable access within contract execution.\n   */\n  get accessList() {\n    const value = this.#accessList || null;\n    if (value == null) {\n      if (this.type === 1 || this.type === 2) {\n        return [];\n      }\n      return null;\n    }\n    return value;\n  }\n  set accessList(value) {\n    this.#accessList = value == null ? null : accessListify(value);\n  }\n  /**\n   *  Creates a new Transaction with default values.\n   */\n  constructor() {\n    this.#type = null;\n    this.#to = null;\n    this.#nonce = 0;\n    this.#gasLimit = BigInt(0);\n    this.#gasPrice = null;\n    this.#maxPriorityFeePerGas = null;\n    this.#maxFeePerGas = null;\n    this.#data = \"0x\";\n    this.#value = BigInt(0);\n    this.#chainId = BigInt(0);\n    this.#sig = null;\n    this.#accessList = null;\n  }\n  /**\n   *  The transaction hash, if signed. Otherwise, ``null``.\n   */\n  get hash() {\n    if (this.signature == null) {\n      return null;\n    }\n    return keccak256(this.serialized);\n  }\n  /**\n   *  The pre-image hash of this transaction.\n   *\n   *  This is the digest that a [[Signer]] must sign to authorize\n   *  this transaction.\n   */\n  get unsignedHash() {\n    return keccak256(this.unsignedSerialized);\n  }\n  /**\n   *  The sending address, if signed. Otherwise, ``null``.\n   */\n  get from() {\n    if (this.signature == null) {\n      return null;\n    }\n    return recoverAddress(this.unsignedHash, this.signature);\n  }\n  /**\n   *  The public key of the sender, if signed. Otherwise, ``null``.\n   */\n  get fromPublicKey() {\n    if (this.signature == null) {\n      return null;\n    }\n    return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);\n  }\n  /**\n   *  Returns true if signed.\n   *\n   *  This provides a Type Guard that properties requiring a signed\n   *  transaction are non-null.\n   */\n  isSigned() {\n    //isSigned(): this is SignedTransaction {\n    return this.signature != null;\n  }\n  /**\n   *  The serialized transaction.\n   *\n   *  This throws if the transaction is unsigned. For the pre-image,\n   *  use [[unsignedSerialized]].\n   */\n  get serialized() {\n    assert(this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", {\n      operation: \".serialized\"\n    });\n    switch (this.inferType()) {\n      case 0:\n        return _serializeLegacy(this, this.signature);\n      case 1:\n        return _serializeEip2930(this, this.signature);\n      case 2:\n        return _serializeEip1559(this, this.signature);\n    }\n    assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n      operation: \".serialized\"\n    });\n  }\n  /**\n   *  The transaction pre-image.\n   *\n   *  The hash of this is the digest which needs to be signed to\n   *  authorize this transaction.\n   */\n  get unsignedSerialized() {\n    switch (this.inferType()) {\n      case 0:\n        return _serializeLegacy(this);\n      case 1:\n        return _serializeEip2930(this);\n      case 2:\n        return _serializeEip1559(this);\n    }\n    assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n      operation: \".unsignedSerialized\"\n    });\n  }\n  /**\n   *  Return the most \"likely\" type; currently the highest\n   *  supported transaction type.\n   */\n  inferType() {\n    return this.inferTypes().pop();\n  }\n  /**\n   *  Validates the explicit properties and returns a list of compatible\n   *  transaction types.\n   */\n  inferTypes() {\n    // Checks that there are no conflicting properties set\n    const hasGasPrice = this.gasPrice != null;\n    const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;\n    const hasAccessList = this.accessList != null;\n    //if (hasGasPrice && hasFee) {\n    //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\n    //}\n    if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\n      assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", {\n        value: this\n      });\n    }\n    //if (this.type === 2 && hasGasPrice) {\n    //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\n    //}\n    assert(!hasFee || this.type !== 0 && this.type !== 1, \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", {\n      value: this\n    });\n    assert(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", {\n      value: this\n    });\n    const types = [];\n    // Explicit type\n    if (this.type != null) {\n      types.push(this.type);\n    } else {\n      if (hasFee) {\n        types.push(2);\n      } else if (hasGasPrice) {\n        types.push(1);\n        if (!hasAccessList) {\n          types.push(0);\n        }\n      } else if (hasAccessList) {\n        types.push(1);\n        types.push(2);\n      } else {\n        types.push(0);\n        types.push(1);\n        types.push(2);\n      }\n    }\n    types.sort();\n    return types;\n  }\n  /**\n   *  Returns true if this transaction is a legacy transaction (i.e.\n   *  ``type === 0``).\n   *\n   *  This provides a Type Guard that the related properties are\n   *  non-null.\n   */\n  isLegacy() {\n    return this.type === 0;\n  }\n  /**\n   *  Returns true if this transaction is berlin hardform transaction (i.e.\n   *  ``type === 1``).\n   *\n   *  This provides a Type Guard that the related properties are\n   *  non-null.\n   */\n  isBerlin() {\n    return this.type === 1;\n  }\n  /**\n   *  Returns true if this transaction is london hardform transaction (i.e.\n   *  ``type === 2``).\n   *\n   *  This provides a Type Guard that the related properties are\n   *  non-null.\n   */\n  isLondon() {\n    return this.type === 2;\n  }\n  /**\n   *  Create a copy of this transaciton.\n   */\n  clone() {\n    return Transaction.from(this);\n  }\n  /**\n   *  Return a JSON-friendly object.\n   */\n  toJSON() {\n    const s = v => {\n      if (v == null) {\n        return null;\n      }\n      return v.toString();\n    };\n    return {\n      type: this.type,\n      to: this.to,\n      //            from: this.from,\n      data: this.data,\n      nonce: this.nonce,\n      gasLimit: s(this.gasLimit),\n      gasPrice: s(this.gasPrice),\n      maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\n      maxFeePerGas: s(this.maxFeePerGas),\n      value: s(this.value),\n      chainId: s(this.chainId),\n      sig: this.signature ? this.signature.toJSON() : null,\n      accessList: this.accessList\n    };\n  }\n  /**\n   *  Create a **Transaction** from a serialized transaction or a\n   *  Transaction-like object.\n   */\n  static from(tx) {\n    if (tx == null) {\n      return new Transaction();\n    }\n    if (typeof tx === \"string\") {\n      const payload = getBytes(tx);\n      if (payload[0] >= 0x7f) {\n        // @TODO: > vs >= ??\n        return Transaction.from(_parseLegacy(payload));\n      }\n      switch (payload[0]) {\n        case 1:\n          return Transaction.from(_parseEip2930(payload));\n        case 2:\n          return Transaction.from(_parseEip1559(payload));\n      }\n      assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"from\"\n      });\n    }\n    const result = new Transaction();\n    if (tx.type != null) {\n      result.type = tx.type;\n    }\n    if (tx.to != null) {\n      result.to = tx.to;\n    }\n    if (tx.nonce != null) {\n      result.nonce = tx.nonce;\n    }\n    if (tx.gasLimit != null) {\n      result.gasLimit = tx.gasLimit;\n    }\n    if (tx.gasPrice != null) {\n      result.gasPrice = tx.gasPrice;\n    }\n    if (tx.maxPriorityFeePerGas != null) {\n      result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n    }\n    if (tx.maxFeePerGas != null) {\n      result.maxFeePerGas = tx.maxFeePerGas;\n    }\n    if (tx.data != null) {\n      result.data = tx.data;\n    }\n    if (tx.value != null) {\n      result.value = tx.value;\n    }\n    if (tx.chainId != null) {\n      result.chainId = tx.chainId;\n    }\n    if (tx.signature != null) {\n      result.signature = Signature.from(tx.signature);\n    }\n    if (tx.accessList != null) {\n      result.accessList = tx.accessList;\n    }\n    if (tx.hash != null) {\n      assertArgument(result.isSigned(), \"unsigned transaction cannot define hash\", \"tx\", tx);\n      assertArgument(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\n    }\n    if (tx.from != null) {\n      assertArgument(result.isSigned(), \"unsigned transaction cannot define from\", \"tx\", tx);\n      assertArgument(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\n    }\n    return result;\n  }\n}","map":{"version":3,"names":["getAddress","keccak256","Signature","SigningKey","concat","decodeRlp","encodeRlp","getBytes","getBigInt","getNumber","hexlify","assert","assertArgument","toBeArray","zeroPadValue","accessListify","recoverAddress","BN_0","BigInt","BN_2","BN_27","BN_28","BN_35","BN_MAX_UINT","handleAddress","value","handleAccessList","param","error","message","handleNumber","_value","handleUint","formatNumber","name","result","length","formatAccessList","map","set","address","storageKeys","_parseLegacy","data","fields","Array","isArray","tx","type","nonce","gasPrice","gasLimit","to","chainId","v","r","s","signature","from","hash","_serializeLegacy","sig","networkV","legacyChainId","legacy","push","yParity","getChainIdV","_parseEipSignature","Error","_parseEip1559","slice","maxPriorityFeePerGas","maxFeePerGas","accessList","_serializeEip1559","_parseEip2930","_serializeEip2930","Transaction","typeName","constructor","serialized","unsignedHash","unsignedSerialized","fromPublicKey","recoverPublicKey","isSigned","operation","inferType","inferTypes","pop","hasGasPrice","hasFee","hasAccessList","types","sort","isLegacy","isBerlin","isLondon","clone","toJSON","toString","payload","toLowerCase"],"sources":["C:/Users/alero/OneDrive/Documentos/GitHub/proyecto/parte C/node_modules/ethers/lib.esm/transaction/transaction.js"],"sourcesContent":["import { getAddress } from \"../address/index.js\";\nimport { keccak256, Signature, SigningKey } from \"../crypto/index.js\";\nimport { concat, decodeRlp, encodeRlp, getBytes, getBigInt, getNumber, hexlify, assert, assertArgument, toBeArray, zeroPadValue } from \"../utils/index.js\";\nimport { accessListify } from \"./accesslist.js\";\nimport { recoverAddress } from \"./address.js\";\nconst BN_0 = BigInt(0);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction handleAddress(value) {\n    if (value === \"0x\") {\n        return null;\n    }\n    return getAddress(value);\n}\nfunction handleAccessList(value, param) {\n    try {\n        return accessListify(value);\n    }\n    catch (error) {\n        assertArgument(false, error.message, param, value);\n    }\n}\nfunction handleNumber(_value, param) {\n    if (_value === \"0x\") {\n        return 0;\n    }\n    return getNumber(_value, param);\n}\nfunction handleUint(_value, param) {\n    if (_value === \"0x\") {\n        return BN_0;\n    }\n    const value = getBigInt(_value, param);\n    assertArgument(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\n    return value;\n}\nfunction formatNumber(_value, name) {\n    const value = getBigInt(_value, \"value\");\n    const result = toBeArray(value);\n    assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);\n    return result;\n}\nfunction formatAccessList(value) {\n    return accessListify(value).map((set) => [set.address, set.storageKeys]);\n}\nfunction _parseLegacy(data) {\n    const fields = decodeRlp(data);\n    assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), \"invalid field count for legacy transaction\", \"data\", data);\n    const tx = {\n        type: 0,\n        nonce: handleNumber(fields[0], \"nonce\"),\n        gasPrice: handleUint(fields[1], \"gasPrice\"),\n        gasLimit: handleUint(fields[2], \"gasLimit\"),\n        to: handleAddress(fields[3]),\n        value: handleUint(fields[4], \"value\"),\n        data: hexlify(fields[5]),\n        chainId: BN_0\n    };\n    // Legacy unsigned transaction\n    if (fields.length === 6) {\n        return tx;\n    }\n    const v = handleUint(fields[6], \"v\");\n    const r = handleUint(fields[7], \"r\");\n    const s = handleUint(fields[8], \"s\");\n    if (r === BN_0 && s === BN_0) {\n        // EIP-155 unsigned transaction\n        tx.chainId = v;\n    }\n    else {\n        // Compute the EIP-155 chain ID (or 0 for legacy)\n        let chainId = (v - BN_35) / BN_2;\n        if (chainId < BN_0) {\n            chainId = BN_0;\n        }\n        tx.chainId = chainId;\n        // Signed Legacy Transaction\n        assertArgument(chainId !== BN_0 || (v === BN_27 || v === BN_28), \"non-canonical legacy v\", \"v\", fields[6]);\n        tx.signature = Signature.from({\n            r: zeroPadValue(fields[7], 32),\n            s: zeroPadValue(fields[8], 32),\n            v\n        });\n        tx.hash = keccak256(data);\n    }\n    return tx;\n}\nfunction _serializeLegacy(tx, sig) {\n    const fields = [\n        formatNumber(tx.nonce || 0, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit || 0, \"gasLimit\"),\n        ((tx.to != null) ? getAddress(tx.to) : \"0x\"),\n        formatNumber(tx.value || 0, \"value\"),\n        (tx.data || \"0x\"),\n    ];\n    let chainId = BN_0;\n    if (tx.chainId != BN_0) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = getBigInt(tx.chainId, \"tx.chainId\");\n        // We have a chainId in the tx and an EIP-155 v in the signature,\n        // make sure they agree with each other\n        assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    }\n    else if (tx.signature) {\n        // No explicit chainId, but EIP-155 have a derived implicit chainId\n        const legacy = tx.signature.legacyChainId;\n        if (legacy != null) {\n            chainId = legacy;\n        }\n    }\n    // Requesting an unsigned transaction\n    if (!sig) {\n        // We have an EIP-155 transaction (chainId was specified and non-zero)\n        if (chainId !== BN_0) {\n            fields.push(toBeArray(chainId));\n            fields.push(\"0x\");\n            fields.push(\"0x\");\n        }\n        return encodeRlp(fields);\n    }\n    // @TODO: We should probably check that tx.signature, chainId, and sig\n    //        match but that logic could break existing code, so schedule\n    //        this for the next major bump.\n    // Compute the EIP-155 v\n    let v = BigInt(27 + sig.yParity);\n    if (chainId !== BN_0) {\n        v = Signature.getChainIdV(chainId, sig.v);\n    }\n    else if (BigInt(sig.v) !== v) {\n        assertArgument(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    }\n    // Add the signature\n    fields.push(toBeArray(v));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n    return encodeRlp(fields);\n}\nfunction _parseEipSignature(tx, fields) {\n    let yParity;\n    try {\n        yParity = handleNumber(fields[0], \"yParity\");\n        if (yParity !== 0 && yParity !== 1) {\n            throw new Error(\"bad yParity\");\n        }\n    }\n    catch (error) {\n        assertArgument(false, \"invalid yParity\", \"yParity\", fields[0]);\n    }\n    const r = zeroPadValue(fields[1], 32);\n    const s = zeroPadValue(fields[2], 32);\n    const signature = Signature.from({ r, s, yParity });\n    tx.signature = signature;\n}\nfunction _parseEip1559(data) {\n    const fields = decodeRlp(getBytes(data).slice(1));\n    assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), \"invalid field count for transaction type: 2\", \"data\", hexlify(data));\n    const maxPriorityFeePerGas = handleUint(fields[2], \"maxPriorityFeePerGas\");\n    const maxFeePerGas = handleUint(fields[3], \"maxFeePerGas\");\n    const tx = {\n        type: 2,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: maxPriorityFeePerGas,\n        maxFeePerGas: maxFeePerGas,\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: hexlify(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\"),\n    };\n    // Unsigned EIP-1559 Transaction\n    if (fields.length === 9) {\n        return tx;\n    }\n    tx.hash = keccak256(data);\n    _parseEipSignature(tx, fields.slice(9));\n    return tx;\n}\nfunction _serializeEip1559(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId || 0, \"chainId\"),\n        formatNumber(tx.nonce || 0, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit || 0, \"gasLimit\"),\n        ((tx.to != null) ? getAddress(tx.to) : \"0x\"),\n        formatNumber(tx.value || 0, \"value\"),\n        (tx.data || \"0x\"),\n        (formatAccessList(tx.accessList || []))\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push(toBeArray(sig.r));\n        fields.push(toBeArray(sig.s));\n    }\n    return concat([\"0x02\", encodeRlp(fields)]);\n}\nfunction _parseEip2930(data) {\n    const fields = decodeRlp(getBytes(data).slice(1));\n    assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), \"invalid field count for transaction type: 1\", \"data\", hexlify(data));\n    const tx = {\n        type: 1,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        gasPrice: handleUint(fields[2], \"gasPrice\"),\n        gasLimit: handleUint(fields[3], \"gasLimit\"),\n        to: handleAddress(fields[4]),\n        value: handleUint(fields[5], \"value\"),\n        data: hexlify(fields[6]),\n        accessList: handleAccessList(fields[7], \"accessList\")\n    };\n    // Unsigned EIP-2930 Transaction\n    if (fields.length === 8) {\n        return tx;\n    }\n    tx.hash = keccak256(data);\n    _parseEipSignature(tx, fields.slice(8));\n    return tx;\n}\nfunction _serializeEip2930(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId || 0, \"chainId\"),\n        formatNumber(tx.nonce || 0, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit || 0, \"gasLimit\"),\n        ((tx.to != null) ? getAddress(tx.to) : \"0x\"),\n        formatNumber(tx.value || 0, \"value\"),\n        (tx.data || \"0x\"),\n        (formatAccessList(tx.accessList || []))\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\n        fields.push(toBeArray(sig.r));\n        fields.push(toBeArray(sig.s));\n    }\n    return concat([\"0x01\", encodeRlp(fields)]);\n}\n/**\n *  A **Transaction** describes an operation to be executed on\n *  Ethereum by an Externally Owned Account (EOA). It includes\n *  who (the [[to]] address), what (the [[data]]) and how much (the\n *  [[value]] in ether) the operation should entail.\n *\n *  @example:\n *    tx = new Transaction()\n *    //_result:\n *\n *    tx.data = \"0x1234\";\n *    //_result:\n */\nexport class Transaction {\n    #type;\n    #to;\n    #data;\n    #nonce;\n    #gasLimit;\n    #gasPrice;\n    #maxPriorityFeePerGas;\n    #maxFeePerGas;\n    #value;\n    #chainId;\n    #sig;\n    #accessList;\n    /**\n     *  The transaction type.\n     *\n     *  If null, the type will be automatically inferred based on\n     *  explicit properties.\n     */\n    get type() { return this.#type; }\n    set type(value) {\n        switch (value) {\n            case null:\n                this.#type = null;\n                break;\n            case 0:\n            case \"legacy\":\n                this.#type = 0;\n                break;\n            case 1:\n            case \"berlin\":\n            case \"eip-2930\":\n                this.#type = 1;\n                break;\n            case 2:\n            case \"london\":\n            case \"eip-1559\":\n                this.#type = 2;\n                break;\n            default:\n                assertArgument(false, \"unsupported transaction type\", \"type\", value);\n        }\n    }\n    /**\n     *  The name of the transaction type.\n     */\n    get typeName() {\n        switch (this.type) {\n            case 0: return \"legacy\";\n            case 1: return \"eip-2930\";\n            case 2: return \"eip-1559\";\n        }\n        return null;\n    }\n    /**\n     *  The ``to`` address for the transaction or ``null`` if the\n     *  transaction is an ``init`` transaction.\n     */\n    get to() { return this.#to; }\n    set to(value) {\n        this.#to = (value == null) ? null : getAddress(value);\n    }\n    /**\n     *  The transaction nonce.\n     */\n    get nonce() { return this.#nonce; }\n    set nonce(value) { this.#nonce = getNumber(value, \"value\"); }\n    /**\n     *  The gas limit.\n     */\n    get gasLimit() { return this.#gasLimit; }\n    set gasLimit(value) { this.#gasLimit = getBigInt(value); }\n    /**\n     *  The gas price.\n     *\n     *  On legacy networks this defines the fee that will be paid. On\n     *  EIP-1559 networks, this should be ``null``.\n     */\n    get gasPrice() {\n        const value = this.#gasPrice;\n        if (value == null && (this.type === 0 || this.type === 1)) {\n            return BN_0;\n        }\n        return value;\n    }\n    set gasPrice(value) {\n        this.#gasPrice = (value == null) ? null : getBigInt(value, \"gasPrice\");\n    }\n    /**\n     *  The maximum priority fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n    get maxPriorityFeePerGas() {\n        const value = this.#maxPriorityFeePerGas;\n        if (value == null) {\n            if (this.type === 2) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxPriorityFeePerGas(value) {\n        this.#maxPriorityFeePerGas = (value == null) ? null : getBigInt(value, \"maxPriorityFeePerGas\");\n    }\n    /**\n     *  The maximum total fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n    get maxFeePerGas() {\n        const value = this.#maxFeePerGas;\n        if (value == null) {\n            if (this.type === 2) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxFeePerGas(value) {\n        this.#maxFeePerGas = (value == null) ? null : getBigInt(value, \"maxFeePerGas\");\n    }\n    /**\n     *  The transaction data. For ``init`` transactions this is the\n     *  deployment code.\n     */\n    get data() { return this.#data; }\n    set data(value) { this.#data = hexlify(value); }\n    /**\n     *  The amount of ether (in wei) to send in this transactions.\n     */\n    get value() { return this.#value; }\n    set value(value) {\n        this.#value = getBigInt(value, \"value\");\n    }\n    /**\n     *  The chain ID this transaction is valid on.\n     */\n    get chainId() { return this.#chainId; }\n    set chainId(value) { this.#chainId = getBigInt(value); }\n    /**\n     *  If signed, the signature for this transaction.\n     */\n    get signature() { return this.#sig || null; }\n    set signature(value) {\n        this.#sig = (value == null) ? null : Signature.from(value);\n    }\n    /**\n     *  The access list.\n     *\n     *  An access list permits discounted (but pre-paid) access to\n     *  bytecode and state variable access within contract execution.\n     */\n    get accessList() {\n        const value = this.#accessList || null;\n        if (value == null) {\n            if (this.type === 1 || this.type === 2) {\n                return [];\n            }\n            return null;\n        }\n        return value;\n    }\n    set accessList(value) {\n        this.#accessList = (value == null) ? null : accessListify(value);\n    }\n    /**\n     *  Creates a new Transaction with default values.\n     */\n    constructor() {\n        this.#type = null;\n        this.#to = null;\n        this.#nonce = 0;\n        this.#gasLimit = BigInt(0);\n        this.#gasPrice = null;\n        this.#maxPriorityFeePerGas = null;\n        this.#maxFeePerGas = null;\n        this.#data = \"0x\";\n        this.#value = BigInt(0);\n        this.#chainId = BigInt(0);\n        this.#sig = null;\n        this.#accessList = null;\n    }\n    /**\n     *  The transaction hash, if signed. Otherwise, ``null``.\n     */\n    get hash() {\n        if (this.signature == null) {\n            return null;\n        }\n        return keccak256(this.serialized);\n    }\n    /**\n     *  The pre-image hash of this transaction.\n     *\n     *  This is the digest that a [[Signer]] must sign to authorize\n     *  this transaction.\n     */\n    get unsignedHash() {\n        return keccak256(this.unsignedSerialized);\n    }\n    /**\n     *  The sending address, if signed. Otherwise, ``null``.\n     */\n    get from() {\n        if (this.signature == null) {\n            return null;\n        }\n        return recoverAddress(this.unsignedHash, this.signature);\n    }\n    /**\n     *  The public key of the sender, if signed. Otherwise, ``null``.\n     */\n    get fromPublicKey() {\n        if (this.signature == null) {\n            return null;\n        }\n        return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);\n    }\n    /**\n     *  Returns true if signed.\n     *\n     *  This provides a Type Guard that properties requiring a signed\n     *  transaction are non-null.\n     */\n    isSigned() {\n        //isSigned(): this is SignedTransaction {\n        return this.signature != null;\n    }\n    /**\n     *  The serialized transaction.\n     *\n     *  This throws if the transaction is unsigned. For the pre-image,\n     *  use [[unsignedSerialized]].\n     */\n    get serialized() {\n        assert(this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", { operation: \".serialized\" });\n        switch (this.inferType()) {\n            case 0:\n                return _serializeLegacy(this, this.signature);\n            case 1:\n                return _serializeEip2930(this, this.signature);\n            case 2:\n                return _serializeEip1559(this, this.signature);\n        }\n        assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \".serialized\" });\n    }\n    /**\n     *  The transaction pre-image.\n     *\n     *  The hash of this is the digest which needs to be signed to\n     *  authorize this transaction.\n     */\n    get unsignedSerialized() {\n        switch (this.inferType()) {\n            case 0:\n                return _serializeLegacy(this);\n            case 1:\n                return _serializeEip2930(this);\n            case 2:\n                return _serializeEip1559(this);\n        }\n        assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \".unsignedSerialized\" });\n    }\n    /**\n     *  Return the most \"likely\" type; currently the highest\n     *  supported transaction type.\n     */\n    inferType() {\n        return (this.inferTypes().pop());\n    }\n    /**\n     *  Validates the explicit properties and returns a list of compatible\n     *  transaction types.\n     */\n    inferTypes() {\n        // Checks that there are no conflicting properties set\n        const hasGasPrice = this.gasPrice != null;\n        const hasFee = (this.maxFeePerGas != null || this.maxPriorityFeePerGas != null);\n        const hasAccessList = (this.accessList != null);\n        //if (hasGasPrice && hasFee) {\n        //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\n        //}\n        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\n            assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", { value: this });\n        }\n        //if (this.type === 2 && hasGasPrice) {\n        //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\n        //}\n        assert(!hasFee || (this.type !== 0 && this.type !== 1), \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", { value: this });\n        assert(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", { value: this });\n        const types = [];\n        // Explicit type\n        if (this.type != null) {\n            types.push(this.type);\n        }\n        else {\n            if (hasFee) {\n                types.push(2);\n            }\n            else if (hasGasPrice) {\n                types.push(1);\n                if (!hasAccessList) {\n                    types.push(0);\n                }\n            }\n            else if (hasAccessList) {\n                types.push(1);\n                types.push(2);\n            }\n            else {\n                types.push(0);\n                types.push(1);\n                types.push(2);\n            }\n        }\n        types.sort();\n        return types;\n    }\n    /**\n     *  Returns true if this transaction is a legacy transaction (i.e.\n     *  ``type === 0``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isLegacy() {\n        return (this.type === 0);\n    }\n    /**\n     *  Returns true if this transaction is berlin hardform transaction (i.e.\n     *  ``type === 1``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isBerlin() {\n        return (this.type === 1);\n    }\n    /**\n     *  Returns true if this transaction is london hardform transaction (i.e.\n     *  ``type === 2``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isLondon() {\n        return (this.type === 2);\n    }\n    /**\n     *  Create a copy of this transaciton.\n     */\n    clone() {\n        return Transaction.from(this);\n    }\n    /**\n     *  Return a JSON-friendly object.\n     */\n    toJSON() {\n        const s = (v) => {\n            if (v == null) {\n                return null;\n            }\n            return v.toString();\n        };\n        return {\n            type: this.type,\n            to: this.to,\n            //            from: this.from,\n            data: this.data,\n            nonce: this.nonce,\n            gasLimit: s(this.gasLimit),\n            gasPrice: s(this.gasPrice),\n            maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\n            maxFeePerGas: s(this.maxFeePerGas),\n            value: s(this.value),\n            chainId: s(this.chainId),\n            sig: this.signature ? this.signature.toJSON() : null,\n            accessList: this.accessList\n        };\n    }\n    /**\n     *  Create a **Transaction** from a serialized transaction or a\n     *  Transaction-like object.\n     */\n    static from(tx) {\n        if (tx == null) {\n            return new Transaction();\n        }\n        if (typeof (tx) === \"string\") {\n            const payload = getBytes(tx);\n            if (payload[0] >= 0x7f) { // @TODO: > vs >= ??\n                return Transaction.from(_parseLegacy(payload));\n            }\n            switch (payload[0]) {\n                case 1: return Transaction.from(_parseEip2930(payload));\n                case 2: return Transaction.from(_parseEip1559(payload));\n            }\n            assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \"from\" });\n        }\n        const result = new Transaction();\n        if (tx.type != null) {\n            result.type = tx.type;\n        }\n        if (tx.to != null) {\n            result.to = tx.to;\n        }\n        if (tx.nonce != null) {\n            result.nonce = tx.nonce;\n        }\n        if (tx.gasLimit != null) {\n            result.gasLimit = tx.gasLimit;\n        }\n        if (tx.gasPrice != null) {\n            result.gasPrice = tx.gasPrice;\n        }\n        if (tx.maxPriorityFeePerGas != null) {\n            result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n        }\n        if (tx.maxFeePerGas != null) {\n            result.maxFeePerGas = tx.maxFeePerGas;\n        }\n        if (tx.data != null) {\n            result.data = tx.data;\n        }\n        if (tx.value != null) {\n            result.value = tx.value;\n        }\n        if (tx.chainId != null) {\n            result.chainId = tx.chainId;\n        }\n        if (tx.signature != null) {\n            result.signature = Signature.from(tx.signature);\n        }\n        if (tx.accessList != null) {\n            result.accessList = tx.accessList;\n        }\n        if (tx.hash != null) {\n            assertArgument(result.isSigned(), \"unsigned transaction cannot define hash\", \"tx\", tx);\n            assertArgument(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\n        }\n        if (tx.from != null) {\n            assertArgument(result.isSigned(), \"unsigned transaction cannot define from\", \"tx\", tx);\n            assertArgument(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=transaction.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}