{"ast":null,"code":"//import { resolveAddress } from \"@ethersproject/address\";\nimport { defineProperties, getBigInt, getNumber, hexlify, resolveProperties, assert, assertArgument, isError, makeError } from \"../utils/index.js\";\nimport { accessListify } from \"../transaction/index.js\";\nconst BN_0 = BigInt(0);\n// -----------------------\nfunction getValue(value) {\n  if (value == null) {\n    return null;\n  }\n  return value;\n}\nfunction toJson(value) {\n  if (value == null) {\n    return null;\n  }\n  return value.toString();\n}\n// @TODO? <T extends FeeData = { }> implements Required<T>\n/**\n *  A **FeeData** wraps all the fee-related values associated with\n *  the network.\n */\nexport class FeeData {\n  /**\n   *  The gas price for legacy networks.\n   */\n  gasPrice;\n  /**\n   *  The maximum fee to pay per gas.\n   *\n   *  The base fee per gas is defined by the network and based on\n   *  congestion, increasing the cost during times of heavy load\n   *  and lowering when less busy.\n   *\n   *  The actual fee per gas will be the base fee for the block\n   *  and the priority fee, up to the max fee per gas.\n   *\n   *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))\n   */\n  maxFeePerGas;\n  /**\n   *  The additional amout to pay per gas to encourage a validator\n   *  to include the transaction.\n   *\n   *  The purpose of this is to compensate the validator for the\n   *  adjusted risk for including a given transaction.\n   *\n   *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))\n   */\n  maxPriorityFeePerGas;\n  /**\n   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and\n   *  %%maxPriorityFeePerGas%%.\n   */\n  constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {\n    defineProperties(this, {\n      gasPrice: getValue(gasPrice),\n      maxFeePerGas: getValue(maxFeePerGas),\n      maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)\n    });\n  }\n  /**\n   *  Returns a JSON-friendly value.\n   */\n  toJSON() {\n    const {\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas\n    } = this;\n    return {\n      _type: \"FeeData\",\n      gasPrice: toJson(gasPrice),\n      maxFeePerGas: toJson(maxFeePerGas),\n      maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)\n    };\n  }\n}\n;\n/**\n *  Returns a copy of %%req%% with all properties coerced to their strict\n *  types.\n */\nexport function copyRequest(req) {\n  const result = {};\n  // These could be addresses, ENS names or Addressables\n  if (req.to) {\n    result.to = req.to;\n  }\n  if (req.from) {\n    result.from = req.from;\n  }\n  if (req.data) {\n    result.data = hexlify(req.data);\n  }\n  const bigIntKeys = \"chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value\".split(/,/);\n  for (const key of bigIntKeys) {\n    if (!(key in req) || req[key] == null) {\n      continue;\n    }\n    result[key] = getBigInt(req[key], `request.${key}`);\n  }\n  const numberKeys = \"type,nonce\".split(/,/);\n  for (const key of numberKeys) {\n    if (!(key in req) || req[key] == null) {\n      continue;\n    }\n    result[key] = getNumber(req[key], `request.${key}`);\n  }\n  if (req.accessList) {\n    result.accessList = accessListify(req.accessList);\n  }\n  if (\"blockTag\" in req) {\n    result.blockTag = req.blockTag;\n  }\n  if (\"enableCcipRead\" in req) {\n    result.enableCcipRead = !!req.enableCcipRead;\n  }\n  if (\"customData\" in req) {\n    result.customData = req.customData;\n  }\n  return result;\n}\n/**\n *  A **Block** represents the data associated with a full block on\n *  Ethereum.\n */\nexport class Block {\n  /**\n   *  The provider connected to the block used to fetch additional details\n   *  if necessary.\n   */\n  provider;\n  /**\n   *  The block number, sometimes called the block height. This is a\n   *  sequential number that is one higher than the parent block.\n   */\n  number;\n  /**\n   *  The block hash.\n   *\n   *  This hash includes all properties, so can be safely used to identify\n   *  an exact set of block properties.\n   */\n  hash;\n  /**\n   *  The timestamp for this block, which is the number of seconds since\n   *  epoch that this block was included.\n   */\n  timestamp;\n  /**\n   *  The block hash of the parent block.\n   */\n  parentHash;\n  /**\n   *  The nonce.\n   *\n   *  On legacy networks, this is the random number inserted which\n   *  permitted the difficulty target to be reached.\n   */\n  nonce;\n  /**\n   *  The difficulty target.\n   *\n   *  On legacy networks, this is the proof-of-work target required\n   *  for a block to meet the protocol rules to be included.\n   *\n   *  On modern networks, this is a random number arrived at using\n   *  randao.  @TODO: Find links?\n   */\n  difficulty;\n  /**\n   *  The total gas limit for this block.\n   */\n  gasLimit;\n  /**\n   *  The total gas used in this block.\n   */\n  gasUsed;\n  /**\n   *  The miner coinbase address, wihch receives any subsidies for\n   *  including this block.\n   */\n  miner;\n  /**\n   *  Any extra data the validator wished to include.\n   */\n  extraData;\n  /**\n   *  The base fee per gas that all transactions in this block were\n   *  charged.\n   *\n   *  This adjusts after each block, depending on how congested the network\n   *  is.\n   */\n  baseFeePerGas;\n  #transactions;\n  /**\n   *  Create a new **Block** object.\n   *\n   *  This should generally not be necessary as the unless implementing a\n   *  low-level library.\n   */\n  constructor(block, provider) {\n    this.#transactions = block.transactions.map(tx => {\n      if (typeof tx !== \"string\") {\n        return new TransactionResponse(tx, provider);\n      }\n      return tx;\n    });\n    defineProperties(this, {\n      provider,\n      hash: getValue(block.hash),\n      number: block.number,\n      timestamp: block.timestamp,\n      parentHash: block.parentHash,\n      nonce: block.nonce,\n      difficulty: block.difficulty,\n      gasLimit: block.gasLimit,\n      gasUsed: block.gasUsed,\n      miner: block.miner,\n      extraData: block.extraData,\n      baseFeePerGas: getValue(block.baseFeePerGas)\n    });\n  }\n  /**\n   *  Returns the list of transaction hashes.\n   */\n  get transactions() {\n    return this.#transactions.map(tx => {\n      if (typeof tx === \"string\") {\n        return tx;\n      }\n      return tx.hash;\n    });\n  }\n  /**\n   *  Returns the complete transactions for blocks which\n   *  prefetched them, by passing ``true`` to %%prefetchTxs%%\n   *  into [[Provider-getBlock]].\n   */\n  get prefetchedTransactions() {\n    const txs = this.#transactions.slice();\n    // Doesn't matter...\n    if (txs.length === 0) {\n      return [];\n    }\n    // Make sure we prefetched the transactions\n    assert(typeof txs[0] === \"object\", \"transactions were not prefetched with block request\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"transactionResponses()\"\n    });\n    return txs;\n  }\n  /**\n   *  Returns a JSON-friendly value.\n   */\n  toJSON() {\n    const {\n      baseFeePerGas,\n      difficulty,\n      extraData,\n      gasLimit,\n      gasUsed,\n      hash,\n      miner,\n      nonce,\n      number,\n      parentHash,\n      timestamp,\n      transactions\n    } = this;\n    return {\n      _type: \"Block\",\n      baseFeePerGas: toJson(baseFeePerGas),\n      difficulty: toJson(difficulty),\n      extraData,\n      gasLimit: toJson(gasLimit),\n      gasUsed: toJson(gasUsed),\n      hash,\n      miner,\n      nonce,\n      number,\n      parentHash,\n      timestamp,\n      transactions\n    };\n  }\n  [Symbol.iterator]() {\n    let index = 0;\n    const txs = this.transactions;\n    return {\n      next: () => {\n        if (index < this.length) {\n          return {\n            value: txs[index++],\n            done: false\n          };\n        }\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n    };\n  }\n  /**\n   *  The number of transactions in this block.\n   */\n  get length() {\n    return this.#transactions.length;\n  }\n  /**\n   *  The [[link-js-date]] this block was included at.\n   */\n  get date() {\n    if (this.timestamp == null) {\n      return null;\n    }\n    return new Date(this.timestamp * 1000);\n  }\n  /**\n   *  Get the transaction at %%indexe%% within this block.\n   */\n  async getTransaction(indexOrHash) {\n    // Find the internal value by its index or hash\n    let tx = undefined;\n    if (typeof indexOrHash === \"number\") {\n      tx = this.#transactions[indexOrHash];\n    } else {\n      const hash = indexOrHash.toLowerCase();\n      for (const v of this.#transactions) {\n        if (typeof v === \"string\") {\n          if (v !== hash) {\n            continue;\n          }\n          tx = v;\n          break;\n        } else {\n          if (v.hash === hash) {\n            continue;\n          }\n          tx = v;\n          break;\n        }\n      }\n    }\n    if (tx == null) {\n      throw new Error(\"no such tx\");\n    }\n    if (typeof tx === \"string\") {\n      return await this.provider.getTransaction(tx);\n    } else {\n      return tx;\n    }\n  }\n  /**\n   *  If a **Block** was fetched with a request to include the transactions\n   *  this will allow synchronous access to those transactions.\n   *\n   *  If the transactions were not prefetched, this will throw.\n   */\n  getPrefetchedTransaction(indexOrHash) {\n    const txs = this.prefetchedTransactions;\n    if (typeof indexOrHash === \"number\") {\n      return txs[indexOrHash];\n    }\n    indexOrHash = indexOrHash.toLowerCase();\n    for (const tx of txs) {\n      if (tx.hash === indexOrHash) {\n        return tx;\n      }\n    }\n    assertArgument(false, \"no matching transaction\", \"indexOrHash\", indexOrHash);\n  }\n  /**\n   *  Returns true if this block been mined. This provides a type guard\n   *  for all properties on a [[MinedBlock]].\n   */\n  isMined() {\n    return !!this.hash;\n  }\n  /**\n   *  Returns true if this block is an [[link-eip-2930]] block.\n   */\n  isLondon() {\n    return !!this.baseFeePerGas;\n  }\n  /**\n   *  @_ignore:\n   */\n  orphanedEvent() {\n    if (!this.isMined()) {\n      throw new Error(\"\");\n    }\n    return createOrphanedBlockFilter(this);\n  }\n}\n//////////////////////\n// Log\n/**\n *  A **Log** in Ethereum represents an event that has been included in a\n *  transaction using the ``LOG*`` opcodes, which are most commonly used by\n *  Solidity's emit for announcing events.\n */\nexport class Log {\n  /**\n   *  The provider connected to the log used to fetch additional details\n   *  if necessary.\n   */\n  provider;\n  /**\n   *  The transaction hash of the transaction this log occurred in. Use the\n   *  [[Log-getTransaction]] to get the [[TransactionResponse]].\n   */\n  transactionHash;\n  /**\n   *  The block hash of the block this log occurred in. Use the\n   *  [[Log-getBlock]] to get the [[Block]].\n   */\n  blockHash;\n  /**\n   *  The block number of the block this log occurred in. It is preferred\n   *  to use the [[Block-hash]] when fetching the related [[Block]],\n   *  since in the case of an orphaned block, the block at that height may\n   *  have changed.\n   */\n  blockNumber;\n  /**\n   *  If the **Log** represents a block that was removed due to an orphaned\n   *  block, this will be true.\n   *\n   *  This can only happen within an orphan event listener.\n   */\n  removed;\n  /**\n   *  The address of the contract that emitted this log.\n   */\n  address;\n  /**\n   *  The data included in this log when it was emitted.\n   */\n  data;\n  /**\n   *  The indexed topics included in this log when it was emitted.\n   *\n   *  All topics are included in the bloom filters, so they can be\n   *  efficiently filtered using the [[Provider-getLogs]] method.\n   */\n  topics;\n  /**\n   *  The index within the block this log occurred at. This is generally\n   *  not useful to developers, but can be used with the various roots\n   *  to proof inclusion within a block.\n   */\n  index;\n  /**\n   *  The index within the transaction of this log.\n   */\n  transactionIndex;\n  /**\n   *  @_ignore:\n   */\n  constructor(log, provider) {\n    this.provider = provider;\n    const topics = Object.freeze(log.topics.slice());\n    defineProperties(this, {\n      transactionHash: log.transactionHash,\n      blockHash: log.blockHash,\n      blockNumber: log.blockNumber,\n      removed: log.removed,\n      address: log.address,\n      data: log.data,\n      topics,\n      index: log.index,\n      transactionIndex: log.transactionIndex\n    });\n  }\n  /**\n   *  Returns a JSON-compatible object.\n   */\n  toJSON() {\n    const {\n      address,\n      blockHash,\n      blockNumber,\n      data,\n      index,\n      removed,\n      topics,\n      transactionHash,\n      transactionIndex\n    } = this;\n    return {\n      _type: \"log\",\n      address,\n      blockHash,\n      blockNumber,\n      data,\n      index,\n      removed,\n      topics,\n      transactionHash,\n      transactionIndex\n    };\n  }\n  /**\n   *  Returns the block that this log occurred in.\n   */\n  async getBlock() {\n    const block = await this.provider.getBlock(this.blockHash);\n    assert(!!block, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n    return block;\n  }\n  /**\n   *  Returns the transaction that this log occurred in.\n   */\n  async getTransaction() {\n    const tx = await this.provider.getTransaction(this.transactionHash);\n    assert(!!tx, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n    return tx;\n  }\n  /**\n   *  Returns the transaction receipt fot the transaction that this\n   *  log occurred in.\n   */\n  async getTransactionReceipt() {\n    const receipt = await this.provider.getTransactionReceipt(this.transactionHash);\n    assert(!!receipt, \"failed to find transaction receipt\", \"UNKNOWN_ERROR\", {});\n    return receipt;\n  }\n  /**\n   *  @_ignore:\n   */\n  removedEvent() {\n    return createRemovedLogFilter(this);\n  }\n}\n//////////////////////\n// Transaction Receipt\n/*\nexport interface LegacyTransactionReceipt {\n    byzantium: false;\n    status: null;\n    root: string;\n}\n\nexport interface ByzantiumTransactionReceipt {\n    byzantium: true;\n    status: number;\n    root: null;\n}\n*/\n/**\n *  A **TransactionReceipt** includes additional information about a\n *  transaction that is only available after it has been mined.\n */\nexport class TransactionReceipt {\n  /**\n   *  The provider connected to the log used to fetch additional details\n   *  if necessary.\n   */\n  provider;\n  /**\n   *  The address the transaction was send to.\n   */\n  to;\n  /**\n   *  The sender of the transaction.\n   */\n  from;\n  /**\n   *  The address of the contract if the transaction was directly\n   *  responsible for deploying one.\n   *\n   *  This is non-null **only** if the ``to`` is empty and the ``data``\n   *  was successfully executed as initcode.\n   */\n  contractAddress;\n  /**\n   *  The transaction hash.\n   */\n  hash;\n  /**\n   *  The index of this transaction within the block transactions.\n   */\n  index;\n  /**\n   *  The block hash of the [[Block]] this transaction was included in.\n   */\n  blockHash;\n  /**\n   *  The block number of the [[Block]] this transaction was included in.\n   */\n  blockNumber;\n  /**\n   *  The bloom filter bytes that represent all logs that occurred within\n   *  this transaction. This is generally not useful for most developers,\n   *  but can be used to validate the included logs.\n   */\n  logsBloom;\n  /**\n   *  The actual amount of gas used by this transaction.\n   *\n   *  When creating a transaction, the amount of gas that will be used can\n   *  only be approximated, but the sender must pay the gas fee for the\n   *  entire gas limit. After the transaction, the difference is refunded.\n   */\n  gasUsed;\n  /**\n   *  The amount of gas used by all transactions within the block for this\n   *  and all transactions with a lower ``index``.\n   *\n   *  This is generally not useful for developers but can be used to\n   *  validate certain aspects of execution.\n   */\n  cumulativeGasUsed;\n  /**\n   *  The actual gas price used during execution.\n   *\n   *  Due to the complexity of [[link-eip-1559]] this value can only\n   *  be caluclated after the transaction has been mined, snce the base\n   *  fee is protocol-enforced.\n   */\n  gasPrice;\n  /**\n   *  The [[link-eip-2718]] transaction type.\n   */\n  type;\n  //readonly byzantium!: boolean;\n  /**\n   *  The status of this transaction, indicating success (i.e. ``1``) or\n   *  a revert (i.e. ``0``).\n   *\n   *  This is available in post-byzantium blocks, but some backends may\n   *  backfill this value.\n   */\n  status;\n  /**\n   *  The root hash of this transaction.\n   *\n   *  This is no present and was only included in pre-byzantium blocks, but\n   *  could be used to validate certain parts of the receipt.\n   */\n  root;\n  #logs;\n  /**\n   *  @_ignore:\n   */\n  constructor(tx, provider) {\n    this.#logs = Object.freeze(tx.logs.map(log => {\n      return new Log(log, provider);\n    }));\n    let gasPrice = BN_0;\n    if (tx.effectiveGasPrice != null) {\n      gasPrice = tx.effectiveGasPrice;\n    } else if (tx.gasPrice != null) {\n      gasPrice = tx.gasPrice;\n    }\n    defineProperties(this, {\n      provider,\n      to: tx.to,\n      from: tx.from,\n      contractAddress: tx.contractAddress,\n      hash: tx.hash,\n      index: tx.index,\n      blockHash: tx.blockHash,\n      blockNumber: tx.blockNumber,\n      logsBloom: tx.logsBloom,\n      gasUsed: tx.gasUsed,\n      cumulativeGasUsed: tx.cumulativeGasUsed,\n      gasPrice,\n      type: tx.type,\n      //byzantium: tx.byzantium,\n      status: tx.status,\n      root: tx.root\n    });\n  }\n  /**\n   *  The logs for this transaction.\n   */\n  get logs() {\n    return this.#logs;\n  }\n  /**\n   *  Returns a JSON-compatible representation.\n   */\n  toJSON() {\n    const {\n      to,\n      from,\n      contractAddress,\n      hash,\n      index,\n      blockHash,\n      blockNumber,\n      logsBloom,\n      logs,\n      //byzantium, \n      status,\n      root\n    } = this;\n    return {\n      _type: \"TransactionReceipt\",\n      blockHash,\n      blockNumber,\n      //byzantium, \n      contractAddress,\n      cumulativeGasUsed: toJson(this.cumulativeGasUsed),\n      from,\n      gasPrice: toJson(this.gasPrice),\n      gasUsed: toJson(this.gasUsed),\n      hash,\n      index,\n      logs,\n      logsBloom,\n      root,\n      status,\n      to\n    };\n  }\n  /**\n   *  @_ignore:\n   */\n  get length() {\n    return this.logs.length;\n  }\n  [Symbol.iterator]() {\n    let index = 0;\n    return {\n      next: () => {\n        if (index < this.length) {\n          return {\n            value: this.logs[index++],\n            done: false\n          };\n        }\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n    };\n  }\n  /**\n   *  The total fee for this transaction, in wei.\n   */\n  get fee() {\n    return this.gasUsed * this.gasPrice;\n  }\n  /**\n   *  Resolves to the block this transaction occurred in.\n   */\n  async getBlock() {\n    const block = await this.provider.getBlock(this.blockHash);\n    if (block == null) {\n      throw new Error(\"TODO\");\n    }\n    return block;\n  }\n  /**\n   *  Resolves to the transaction this transaction occurred in.\n   */\n  async getTransaction() {\n    const tx = await this.provider.getTransaction(this.hash);\n    if (tx == null) {\n      throw new Error(\"TODO\");\n    }\n    return tx;\n  }\n  /**\n   *  Resolves to the return value of the execution of this transaction.\n   *\n   *  Support for this feature is limited, as it requires an archive node\n   *  with the ``debug_`` or ``trace_`` API enabled.\n   */\n  async getResult() {\n    return await this.provider.getTransactionResult(this.hash);\n  }\n  /**\n   *  Resolves to the number of confirmations this transaction has.\n   */\n  async confirmations() {\n    return (await this.provider.getBlockNumber()) - this.blockNumber + 1;\n  }\n  /**\n   *  @_ignore:\n   */\n  removedEvent() {\n    return createRemovedTransactionFilter(this);\n  }\n  /**\n   *  @_ignore:\n   */\n  reorderedEvent(other) {\n    assert(!other || other.isMined(), \"unmined 'other' transction cannot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"reorderedEvent(other)\"\n    });\n    return createReorderedTransactionFilter(this, other);\n  }\n}\n/**\n *  A **TransactionResponse** includes all properties about a transaction\n *  that was sent to the network, which may or may not be included in a\n *  block.\n *\n *  The [[TransactionResponse-isMined]] can be used to check if the\n *  transaction has been mined as well as type guard that the otherwise\n *  possibly ``null`` properties are defined.\n */\nexport class TransactionResponse {\n  /**\n   *  The provider this is connected to, which will influence how its\n   *  methods will resolve its async inspection methods.\n   */\n  provider;\n  /**\n   *  The block number of the block that this transaction was included in.\n   *\n   *  This is ``null`` for pending transactions.\n   */\n  blockNumber;\n  /**\n   *  The blockHash of the block that this transaction was included in.\n   *\n   *  This is ``null`` for pending transactions.\n   */\n  blockHash;\n  /**\n   *  The index within the block that this transaction resides at.\n   */\n  index;\n  /**\n   *  The transaction hash.\n   */\n  hash;\n  /**\n   *  The [[link-eip-2718]] transaction envelope type. This is\n   *  ``0`` for legacy transactions types.\n   */\n  type;\n  /**\n   *  The receiver of this transaction.\n   *\n   *  If ``null``, then the transaction is an initcode transaction.\n   *  This means the result of executing the [[data]] will be deployed\n   *  as a new contract on chain (assuming it does not revert) and the\n   *  address may be computed using [[getCreateAddress]].\n   */\n  to;\n  /**\n   *  The sender of this transaction. It is implicitly computed\n   *  from the transaction pre-image hash (as the digest) and the\n   *  [[signature]] using ecrecover.\n   */\n  from;\n  /**\n   *  The nonce, which is used to prevent replay attacks and offer\n   *  a method to ensure transactions from a given sender are explicitly\n   *  ordered.\n   *\n   *  When sending a transaction, this must be equal to the number of\n   *  transactions ever sent by [[from]].\n   */\n  nonce;\n  /**\n   *  The maximum units of gas this transaction can consume. If execution\n   *  exceeds this, the entries transaction is reverted and the sender\n   *  is charged for the full amount, despite not state changes being made.\n   */\n  gasLimit;\n  /**\n   *  The gas price can have various values, depending on the network.\n   *\n   *  In modern networks, for transactions that are included this is\n   *  the //effective gas price// (the fee per gas that was actually\n   *  charged), while for transactions that have not been included yet\n   *  is the [[maxFeePerGas]].\n   *\n   *  For legacy transactions, or transactions on legacy networks, this\n   *  is the fee that will be charged per unit of gas the transaction\n   *  consumes.\n   */\n  gasPrice;\n  /**\n   *  The maximum priority fee (per unit of gas) to allow a\n   *  validator to charge the sender. This is inclusive of the\n   *  [[maxFeeFeePerGas]].\n   */\n  maxPriorityFeePerGas;\n  /**\n   *  The maximum fee (per unit of gas) to allow this transaction\n   *  to charge the sender.\n   */\n  maxFeePerGas;\n  /**\n   *  The data.\n   */\n  data;\n  /**\n   *  The value, in wei. Use [[formatEther]] to format this value\n   *  as ether.\n   */\n  value;\n  /**\n   *  The chain ID.\n   */\n  chainId;\n  /**\n   *  The signature.\n   */\n  signature;\n  /**\n   *  The [[link-eip-2930]] access list for transaction types that\n   *  support it, otherwise ``null``.\n   */\n  accessList;\n  #startBlock;\n  /**\n   *  @_ignore:\n   */\n  constructor(tx, provider) {\n    this.provider = provider;\n    this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;\n    this.blockHash = tx.blockHash != null ? tx.blockHash : null;\n    this.hash = tx.hash;\n    this.index = tx.index;\n    this.type = tx.type;\n    this.from = tx.from;\n    this.to = tx.to || null;\n    this.gasLimit = tx.gasLimit;\n    this.nonce = tx.nonce;\n    this.data = tx.data;\n    this.value = tx.value;\n    this.gasPrice = tx.gasPrice;\n    this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;\n    this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;\n    this.chainId = tx.chainId;\n    this.signature = tx.signature;\n    this.accessList = tx.accessList != null ? tx.accessList : null;\n    this.#startBlock = -1;\n  }\n  /**\n   *  Returns a JSON-compatible representation of this transaction.\n   */\n  toJSON() {\n    const {\n      blockNumber,\n      blockHash,\n      index,\n      hash,\n      type,\n      to,\n      from,\n      nonce,\n      data,\n      signature,\n      accessList\n    } = this;\n    return {\n      _type: \"TransactionReceipt\",\n      accessList,\n      blockNumber,\n      blockHash,\n      chainId: toJson(this.chainId),\n      data,\n      from,\n      gasLimit: toJson(this.gasLimit),\n      gasPrice: toJson(this.gasPrice),\n      hash,\n      maxFeePerGas: toJson(this.maxFeePerGas),\n      maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),\n      nonce,\n      signature,\n      to,\n      index,\n      type,\n      value: toJson(this.value)\n    };\n  }\n  /**\n   *  Resolves to the Block that this transaction was included in.\n   *\n   *  This will return null if the transaction has not been included yet.\n   */\n  async getBlock() {\n    let blockNumber = this.blockNumber;\n    if (blockNumber == null) {\n      const tx = await this.getTransaction();\n      if (tx) {\n        blockNumber = tx.blockNumber;\n      }\n    }\n    if (blockNumber == null) {\n      return null;\n    }\n    const block = this.provider.getBlock(blockNumber);\n    if (block == null) {\n      throw new Error(\"TODO\");\n    }\n    return block;\n  }\n  /**\n   *  Resolves to this transaction being re-requested from the\n   *  provider. This can be used if you have an unmined transaction\n   *  and wish to get an up-to-date populated instance.\n   */\n  async getTransaction() {\n    return this.provider.getTransaction(this.hash);\n  }\n  /**\n   *  Resolve to the number of confirmations this transaction has.\n   */\n  async confirmations() {\n    if (this.blockNumber == null) {\n      const {\n        tx,\n        blockNumber\n      } = await resolveProperties({\n        tx: this.getTransaction(),\n        blockNumber: this.provider.getBlockNumber()\n      });\n      // Not mined yet...\n      if (tx == null || tx.blockNumber == null) {\n        return 0;\n      }\n      return blockNumber - tx.blockNumber + 1;\n    }\n    const blockNumber = await this.provider.getBlockNumber();\n    return blockNumber - this.blockNumber + 1;\n  }\n  /**\n   *  Resolves once this transaction has been mined and has\n   *  %%confirms%% blocks including it (default: ``1``) with an\n   *  optional %%timeout%%.\n   *\n   *  This can resolve to ``null`` only if %%confirms%% is ``0``\n   *  and the transaction has not been mined, otherwise this will\n   *  wait until enough confirmations have completed.\n   */\n  async wait(_confirms, _timeout) {\n    const confirms = _confirms == null ? 1 : _confirms;\n    const timeout = _timeout == null ? 0 : _timeout;\n    let startBlock = this.#startBlock;\n    let nextScan = -1;\n    let stopScanning = startBlock === -1 ? true : false;\n    const checkReplacement = async () => {\n      // Get the current transaction count for this sender\n      if (stopScanning) {\n        return null;\n      }\n      const {\n        blockNumber,\n        nonce\n      } = await resolveProperties({\n        blockNumber: this.provider.getBlockNumber(),\n        nonce: this.provider.getTransactionCount(this.from)\n      });\n      // No transaction or our nonce has not been mined yet; but we\n      // can start scanning later when we do start\n      if (nonce < this.nonce) {\n        startBlock = blockNumber;\n        return;\n      }\n      // We were mined; no replacement\n      if (stopScanning) {\n        return null;\n      }\n      const mined = await this.getTransaction();\n      if (mined && mined.blockNumber != null) {\n        return;\n      }\n      // We were replaced; start scanning for that transaction\n      // Starting to scan; look back a few extra blocks for safety\n      if (nextScan === -1) {\n        nextScan = startBlock - 3;\n        if (nextScan < this.#startBlock) {\n          nextScan = this.#startBlock;\n        }\n      }\n      while (nextScan <= blockNumber) {\n        // Get the next block to scan\n        if (stopScanning) {\n          return null;\n        }\n        const block = await this.provider.getBlock(nextScan, true);\n        // This should not happen; but we'll try again shortly\n        if (block == null) {\n          return;\n        }\n        // We were mined; no replacement\n        for (const hash of block) {\n          if (hash === this.hash) {\n            return;\n          }\n        }\n        // Search for the transaction that replaced us\n        for (let i = 0; i < block.length; i++) {\n          const tx = await block.getTransaction(i);\n          if (tx.from === this.from && tx.nonce === this.nonce) {\n            // Get the receipt\n            if (stopScanning) {\n              return null;\n            }\n            const receipt = await this.provider.getTransactionReceipt(tx.hash);\n            // This should not happen; but we'll try again shortly\n            if (receipt == null) {\n              return;\n            }\n            // We will retry this on the next block (this case could be optimized)\n            if (blockNumber - receipt.blockNumber + 1 < confirms) {\n              return;\n            }\n            // The reason we were replaced\n            let reason = \"replaced\";\n            if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {\n              reason = \"repriced\";\n            } else if (tx.data === \"0x\" && tx.from === tx.to && tx.value === BN_0) {\n              reason = \"cancelled\";\n            }\n            assert(false, \"transaction was replaced\", \"TRANSACTION_REPLACED\", {\n              cancelled: reason === \"replaced\" || reason === \"cancelled\",\n              reason,\n              replacement: tx.replaceableTransaction(startBlock),\n              hash: tx.hash,\n              receipt\n            });\n          }\n        }\n        nextScan++;\n      }\n      return;\n    };\n    const checkReceipt = receipt => {\n      if (receipt == null || receipt.status !== 0) {\n        return receipt;\n      }\n      assert(false, \"transaction execution reverted\", \"CALL_EXCEPTION\", {\n        action: \"sendTransaction\",\n        data: null,\n        reason: null,\n        invocation: null,\n        revert: null,\n        transaction: {\n          to: receipt.to,\n          from: receipt.from,\n          data: \"\" // @TODO: in v7, split out sendTransaction properties\n        },\n        receipt\n      });\n    };\n    const receipt = await this.provider.getTransactionReceipt(this.hash);\n    if (confirms === 0) {\n      return checkReceipt(receipt);\n    }\n    if (receipt) {\n      if ((await receipt.confirmations()) >= confirms) {\n        return checkReceipt(receipt);\n      }\n    } else {\n      // Check for a replacement; throws if a replacement was found\n      await checkReplacement();\n      // Allow null only when the confirms is 0\n      if (confirms === 0) {\n        return null;\n      }\n    }\n    const waiter = new Promise((resolve, reject) => {\n      // List of things to cancel when we have a result (one way or the other)\n      const cancellers = [];\n      const cancel = () => {\n        cancellers.forEach(c => c());\n      };\n      // On cancel, stop scanning for replacements\n      cancellers.push(() => {\n        stopScanning = true;\n      });\n      // Set up any timeout requested\n      if (timeout > 0) {\n        const timer = setTimeout(() => {\n          cancel();\n          reject(makeError(\"wait for transaction timeout\", \"TIMEOUT\"));\n        }, timeout);\n        cancellers.push(() => {\n          clearTimeout(timer);\n        });\n      }\n      const txListener = async receipt => {\n        // Done; return it!\n        if ((await receipt.confirmations()) >= confirms) {\n          cancel();\n          try {\n            resolve(checkReceipt(receipt));\n          } catch (error) {\n            reject(error);\n          }\n        }\n      };\n      cancellers.push(() => {\n        this.provider.off(this.hash, txListener);\n      });\n      this.provider.on(this.hash, txListener);\n      // We support replacement detection; start checking\n      if (startBlock >= 0) {\n        const replaceListener = async () => {\n          try {\n            // Check for a replacement; this throws only if one is found\n            await checkReplacement();\n          } catch (error) {\n            // We were replaced (with enough confirms); re-throw the error\n            if (isError(error, \"TRANSACTION_REPLACED\")) {\n              cancel();\n              reject(error);\n              return;\n            }\n          }\n          // Rescheudle a check on the next block\n          if (!stopScanning) {\n            this.provider.once(\"block\", replaceListener);\n          }\n        };\n        cancellers.push(() => {\n          this.provider.off(\"block\", replaceListener);\n        });\n        this.provider.once(\"block\", replaceListener);\n      }\n    });\n    return await waiter;\n  }\n  /**\n   *  Returns ``true`` if this transaction has been included.\n   *\n   *  This is effective only as of the time the TransactionResponse\n   *  was instantiated. To get up-to-date information, use\n   *  [[getTransaction]].\n   *\n   *  This provides a Type Guard that this transaction will have\n   *  non-null property values for properties that are null for\n   *  unmined transactions.\n   */\n  isMined() {\n    return this.blockHash != null;\n  }\n  /**\n   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)\n   *  transaction.\n   *\n   *  This provides a Type Guard that this transaction will have\n   *  the ``null``-ness for hardfork-specific properties set correctly.\n   */\n  isLegacy() {\n    return this.type === 0;\n  }\n  /**\n   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)\n   *  transaction. See [[link-eip-2070]].\n   *\n   *  This provides a Type Guard that this transaction will have\n   *  the ``null``-ness for hardfork-specific properties set correctly.\n   */\n  isBerlin() {\n    return this.type === 1;\n  }\n  /**\n   *  Returns true if the transaction is a London (i.e. ``type == 2``)\n   *  transaction. See [[link-eip-1559]].\n   *\n   *  This provides a Type Guard that this transaction will have\n   *  the ``null``-ness for hardfork-specific properties set correctly.\n   */\n  isLondon() {\n    return this.type === 2;\n  }\n  /**\n   *  Returns a filter which can be used to listen for orphan events\n   *  that evict this transaction.\n   */\n  removedEvent() {\n    assert(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"removeEvent()\"\n    });\n    return createRemovedTransactionFilter(this);\n  }\n  /**\n   *  Returns a filter which can be used to listen for orphan events\n   *  that re-order this event against %%other%%.\n   */\n  reorderedEvent(other) {\n    assert(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"removeEvent()\"\n    });\n    assert(!other || other.isMined(), \"unmined 'other' transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"removeEvent()\"\n    });\n    return createReorderedTransactionFilter(this, other);\n  }\n  /**\n   *  Returns a new TransactionResponse instance which has the ability to\n   *  detect (and throw an error) if the transaction is replaced, which\n   *  will begin scanning at %%startBlock%%.\n   *\n   *  This should generally not be used by developers and is intended\n   *  primarily for internal use. Setting an incorrect %%startBlock%% can\n   *  have devastating performance consequences if used incorrectly.\n   */\n  replaceableTransaction(startBlock) {\n    assertArgument(Number.isInteger(startBlock) && startBlock >= 0, \"invalid startBlock\", \"startBlock\", startBlock);\n    const tx = new TransactionResponse(this, this.provider);\n    tx.#startBlock = startBlock;\n    return tx;\n  }\n}\nfunction createOrphanedBlockFilter(block) {\n  return {\n    orphan: \"drop-block\",\n    hash: block.hash,\n    number: block.number\n  };\n}\nfunction createReorderedTransactionFilter(tx, other) {\n  return {\n    orphan: \"reorder-transaction\",\n    tx,\n    other\n  };\n}\nfunction createRemovedTransactionFilter(tx) {\n  return {\n    orphan: \"drop-transaction\",\n    tx\n  };\n}\nfunction createRemovedLogFilter(log) {\n  return {\n    orphan: \"drop-log\",\n    log: {\n      transactionHash: log.transactionHash,\n      blockHash: log.blockHash,\n      blockNumber: log.blockNumber,\n      address: log.address,\n      data: log.data,\n      topics: Object.freeze(log.topics.slice()),\n      index: log.index\n    }\n  };\n}","map":{"version":3,"names":["defineProperties","getBigInt","getNumber","hexlify","resolveProperties","assert","assertArgument","isError","makeError","accessListify","BN_0","BigInt","getValue","value","toJson","toString","FeeData","gasPrice","maxFeePerGas","maxPriorityFeePerGas","constructor","toJSON","_type","copyRequest","req","result","to","from","data","bigIntKeys","split","key","numberKeys","accessList","blockTag","enableCcipRead","customData","Block","provider","number","hash","timestamp","parentHash","nonce","difficulty","gasLimit","gasUsed","miner","extraData","baseFeePerGas","transactions","block","map","tx","TransactionResponse","prefetchedTransactions","txs","slice","length","operation","Symbol","iterator","index","next","done","undefined","date","Date","getTransaction","indexOrHash","toLowerCase","v","Error","getPrefetchedTransaction","isMined","isLondon","orphanedEvent","createOrphanedBlockFilter","Log","transactionHash","blockHash","blockNumber","removed","address","topics","transactionIndex","log","Object","freeze","getBlock","getTransactionReceipt","receipt","removedEvent","createRemovedLogFilter","TransactionReceipt","contractAddress","logsBloom","cumulativeGasUsed","type","status","root","logs","effectiveGasPrice","fee","getResult","getTransactionResult","confirmations","getBlockNumber","createRemovedTransactionFilter","reorderedEvent","other","createReorderedTransactionFilter","chainId","signature","startBlock","wait","_confirms","_timeout","confirms","timeout","nextScan","stopScanning","checkReplacement","getTransactionCount","mined","i","reason","cancelled","replacement","replaceableTransaction","checkReceipt","action","invocation","revert","transaction","waiter","Promise","resolve","reject","cancellers","cancel","forEach","c","push","timer","setTimeout","clearTimeout","txListener","error","off","on","replaceListener","once","isLegacy","isBerlin","Number","isInteger","orphan"],"sources":["C:/Users/alero/OneDrive/Documentos/GitHub/proyecto/parte C/node_modules/ethers/lib.esm/providers/provider.js"],"sourcesContent":["//import { resolveAddress } from \"@ethersproject/address\";\nimport { defineProperties, getBigInt, getNumber, hexlify, resolveProperties, assert, assertArgument, isError, makeError } from \"../utils/index.js\";\nimport { accessListify } from \"../transaction/index.js\";\nconst BN_0 = BigInt(0);\n// -----------------------\nfunction getValue(value) {\n    if (value == null) {\n        return null;\n    }\n    return value;\n}\nfunction toJson(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.toString();\n}\n// @TODO? <T extends FeeData = { }> implements Required<T>\n/**\n *  A **FeeData** wraps all the fee-related values associated with\n *  the network.\n */\nexport class FeeData {\n    /**\n     *  The gas price for legacy networks.\n     */\n    gasPrice;\n    /**\n     *  The maximum fee to pay per gas.\n     *\n     *  The base fee per gas is defined by the network and based on\n     *  congestion, increasing the cost during times of heavy load\n     *  and lowering when less busy.\n     *\n     *  The actual fee per gas will be the base fee for the block\n     *  and the priority fee, up to the max fee per gas.\n     *\n     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))\n     */\n    maxFeePerGas;\n    /**\n     *  The additional amout to pay per gas to encourage a validator\n     *  to include the transaction.\n     *\n     *  The purpose of this is to compensate the validator for the\n     *  adjusted risk for including a given transaction.\n     *\n     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))\n     */\n    maxPriorityFeePerGas;\n    /**\n     *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and\n     *  %%maxPriorityFeePerGas%%.\n     */\n    constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {\n        defineProperties(this, {\n            gasPrice: getValue(gasPrice),\n            maxFeePerGas: getValue(maxFeePerGas),\n            maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)\n        });\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */\n    toJSON() {\n        const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;\n        return {\n            _type: \"FeeData\",\n            gasPrice: toJson(gasPrice),\n            maxFeePerGas: toJson(maxFeePerGas),\n            maxPriorityFeePerGas: toJson(maxPriorityFeePerGas),\n        };\n    }\n}\n;\n/**\n *  Returns a copy of %%req%% with all properties coerced to their strict\n *  types.\n */\nexport function copyRequest(req) {\n    const result = {};\n    // These could be addresses, ENS names or Addressables\n    if (req.to) {\n        result.to = req.to;\n    }\n    if (req.from) {\n        result.from = req.from;\n    }\n    if (req.data) {\n        result.data = hexlify(req.data);\n    }\n    const bigIntKeys = \"chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value\".split(/,/);\n    for (const key of bigIntKeys) {\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = getBigInt(req[key], `request.${key}`);\n    }\n    const numberKeys = \"type,nonce\".split(/,/);\n    for (const key of numberKeys) {\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = getNumber(req[key], `request.${key}`);\n    }\n    if (req.accessList) {\n        result.accessList = accessListify(req.accessList);\n    }\n    if (\"blockTag\" in req) {\n        result.blockTag = req.blockTag;\n    }\n    if (\"enableCcipRead\" in req) {\n        result.enableCcipRead = !!req.enableCcipRead;\n    }\n    if (\"customData\" in req) {\n        result.customData = req.customData;\n    }\n    return result;\n}\n/**\n *  A **Block** represents the data associated with a full block on\n *  Ethereum.\n */\nexport class Block {\n    /**\n     *  The provider connected to the block used to fetch additional details\n     *  if necessary.\n     */\n    provider;\n    /**\n     *  The block number, sometimes called the block height. This is a\n     *  sequential number that is one higher than the parent block.\n     */\n    number;\n    /**\n     *  The block hash.\n     *\n     *  This hash includes all properties, so can be safely used to identify\n     *  an exact set of block properties.\n     */\n    hash;\n    /**\n     *  The timestamp for this block, which is the number of seconds since\n     *  epoch that this block was included.\n     */\n    timestamp;\n    /**\n     *  The block hash of the parent block.\n     */\n    parentHash;\n    /**\n     *  The nonce.\n     *\n     *  On legacy networks, this is the random number inserted which\n     *  permitted the difficulty target to be reached.\n     */\n    nonce;\n    /**\n     *  The difficulty target.\n     *\n     *  On legacy networks, this is the proof-of-work target required\n     *  for a block to meet the protocol rules to be included.\n     *\n     *  On modern networks, this is a random number arrived at using\n     *  randao.  @TODO: Find links?\n     */\n    difficulty;\n    /**\n     *  The total gas limit for this block.\n     */\n    gasLimit;\n    /**\n     *  The total gas used in this block.\n     */\n    gasUsed;\n    /**\n     *  The miner coinbase address, wihch receives any subsidies for\n     *  including this block.\n     */\n    miner;\n    /**\n     *  Any extra data the validator wished to include.\n     */\n    extraData;\n    /**\n     *  The base fee per gas that all transactions in this block were\n     *  charged.\n     *\n     *  This adjusts after each block, depending on how congested the network\n     *  is.\n     */\n    baseFeePerGas;\n    #transactions;\n    /**\n     *  Create a new **Block** object.\n     *\n     *  This should generally not be necessary as the unless implementing a\n     *  low-level library.\n     */\n    constructor(block, provider) {\n        this.#transactions = block.transactions.map((tx) => {\n            if (typeof (tx) !== \"string\") {\n                return new TransactionResponse(tx, provider);\n            }\n            return tx;\n        });\n        defineProperties(this, {\n            provider,\n            hash: getValue(block.hash),\n            number: block.number,\n            timestamp: block.timestamp,\n            parentHash: block.parentHash,\n            nonce: block.nonce,\n            difficulty: block.difficulty,\n            gasLimit: block.gasLimit,\n            gasUsed: block.gasUsed,\n            miner: block.miner,\n            extraData: block.extraData,\n            baseFeePerGas: getValue(block.baseFeePerGas)\n        });\n    }\n    /**\n     *  Returns the list of transaction hashes.\n     */\n    get transactions() {\n        return this.#transactions.map((tx) => {\n            if (typeof (tx) === \"string\") {\n                return tx;\n            }\n            return tx.hash;\n        });\n    }\n    /**\n     *  Returns the complete transactions for blocks which\n     *  prefetched them, by passing ``true`` to %%prefetchTxs%%\n     *  into [[Provider-getBlock]].\n     */\n    get prefetchedTransactions() {\n        const txs = this.#transactions.slice();\n        // Doesn't matter...\n        if (txs.length === 0) {\n            return [];\n        }\n        // Make sure we prefetched the transactions\n        assert(typeof (txs[0]) === \"object\", \"transactions were not prefetched with block request\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"transactionResponses()\"\n        });\n        return txs;\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */\n    toJSON() {\n        const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash, miner, nonce, number, parentHash, timestamp, transactions } = this;\n        return {\n            _type: \"Block\",\n            baseFeePerGas: toJson(baseFeePerGas),\n            difficulty: toJson(difficulty),\n            extraData,\n            gasLimit: toJson(gasLimit),\n            gasUsed: toJson(gasUsed),\n            hash, miner, nonce, number, parentHash, timestamp,\n            transactions,\n        };\n    }\n    [Symbol.iterator]() {\n        let index = 0;\n        const txs = this.transactions;\n        return {\n            next: () => {\n                if (index < this.length) {\n                    return {\n                        value: txs[index++], done: false\n                    };\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n    /**\n     *  The number of transactions in this block.\n     */\n    get length() { return this.#transactions.length; }\n    /**\n     *  The [[link-js-date]] this block was included at.\n     */\n    get date() {\n        if (this.timestamp == null) {\n            return null;\n        }\n        return new Date(this.timestamp * 1000);\n    }\n    /**\n     *  Get the transaction at %%indexe%% within this block.\n     */\n    async getTransaction(indexOrHash) {\n        // Find the internal value by its index or hash\n        let tx = undefined;\n        if (typeof (indexOrHash) === \"number\") {\n            tx = this.#transactions[indexOrHash];\n        }\n        else {\n            const hash = indexOrHash.toLowerCase();\n            for (const v of this.#transactions) {\n                if (typeof (v) === \"string\") {\n                    if (v !== hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                }\n                else {\n                    if (v.hash === hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                }\n            }\n        }\n        if (tx == null) {\n            throw new Error(\"no such tx\");\n        }\n        if (typeof (tx) === \"string\") {\n            return (await this.provider.getTransaction(tx));\n        }\n        else {\n            return tx;\n        }\n    }\n    /**\n     *  If a **Block** was fetched with a request to include the transactions\n     *  this will allow synchronous access to those transactions.\n     *\n     *  If the transactions were not prefetched, this will throw.\n     */\n    getPrefetchedTransaction(indexOrHash) {\n        const txs = this.prefetchedTransactions;\n        if (typeof (indexOrHash) === \"number\") {\n            return txs[indexOrHash];\n        }\n        indexOrHash = indexOrHash.toLowerCase();\n        for (const tx of txs) {\n            if (tx.hash === indexOrHash) {\n                return tx;\n            }\n        }\n        assertArgument(false, \"no matching transaction\", \"indexOrHash\", indexOrHash);\n    }\n    /**\n     *  Returns true if this block been mined. This provides a type guard\n     *  for all properties on a [[MinedBlock]].\n     */\n    isMined() { return !!this.hash; }\n    /**\n     *  Returns true if this block is an [[link-eip-2930]] block.\n     */\n    isLondon() {\n        return !!this.baseFeePerGas;\n    }\n    /**\n     *  @_ignore:\n     */\n    orphanedEvent() {\n        if (!this.isMined()) {\n            throw new Error(\"\");\n        }\n        return createOrphanedBlockFilter(this);\n    }\n}\n//////////////////////\n// Log\n/**\n *  A **Log** in Ethereum represents an event that has been included in a\n *  transaction using the ``LOG*`` opcodes, which are most commonly used by\n *  Solidity's emit for announcing events.\n */\nexport class Log {\n    /**\n     *  The provider connected to the log used to fetch additional details\n     *  if necessary.\n     */\n    provider;\n    /**\n     *  The transaction hash of the transaction this log occurred in. Use the\n     *  [[Log-getTransaction]] to get the [[TransactionResponse]].\n     */\n    transactionHash;\n    /**\n     *  The block hash of the block this log occurred in. Use the\n     *  [[Log-getBlock]] to get the [[Block]].\n     */\n    blockHash;\n    /**\n     *  The block number of the block this log occurred in. It is preferred\n     *  to use the [[Block-hash]] when fetching the related [[Block]],\n     *  since in the case of an orphaned block, the block at that height may\n     *  have changed.\n     */\n    blockNumber;\n    /**\n     *  If the **Log** represents a block that was removed due to an orphaned\n     *  block, this will be true.\n     *\n     *  This can only happen within an orphan event listener.\n     */\n    removed;\n    /**\n     *  The address of the contract that emitted this log.\n     */\n    address;\n    /**\n     *  The data included in this log when it was emitted.\n     */\n    data;\n    /**\n     *  The indexed topics included in this log when it was emitted.\n     *\n     *  All topics are included in the bloom filters, so they can be\n     *  efficiently filtered using the [[Provider-getLogs]] method.\n     */\n    topics;\n    /**\n     *  The index within the block this log occurred at. This is generally\n     *  not useful to developers, but can be used with the various roots\n     *  to proof inclusion within a block.\n     */\n    index;\n    /**\n     *  The index within the transaction of this log.\n     */\n    transactionIndex;\n    /**\n     *  @_ignore:\n     */\n    constructor(log, provider) {\n        this.provider = provider;\n        const topics = Object.freeze(log.topics.slice());\n        defineProperties(this, {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            removed: log.removed,\n            address: log.address,\n            data: log.data,\n            topics,\n            index: log.index,\n            transactionIndex: log.transactionIndex,\n        });\n    }\n    /**\n     *  Returns a JSON-compatible object.\n     */\n    toJSON() {\n        const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;\n        return {\n            _type: \"log\",\n            address, blockHash, blockNumber, data, index,\n            removed, topics, transactionHash, transactionIndex\n        };\n    }\n    /**\n     *  Returns the block that this log occurred in.\n     */\n    async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        assert(!!block, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return block;\n    }\n    /**\n     *  Returns the transaction that this log occurred in.\n     */\n    async getTransaction() {\n        const tx = await this.provider.getTransaction(this.transactionHash);\n        assert(!!tx, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return tx;\n    }\n    /**\n     *  Returns the transaction receipt fot the transaction that this\n     *  log occurred in.\n     */\n    async getTransactionReceipt() {\n        const receipt = await this.provider.getTransactionReceipt(this.transactionHash);\n        assert(!!receipt, \"failed to find transaction receipt\", \"UNKNOWN_ERROR\", {});\n        return receipt;\n    }\n    /**\n     *  @_ignore:\n     */\n    removedEvent() {\n        return createRemovedLogFilter(this);\n    }\n}\n//////////////////////\n// Transaction Receipt\n/*\nexport interface LegacyTransactionReceipt {\n    byzantium: false;\n    status: null;\n    root: string;\n}\n\nexport interface ByzantiumTransactionReceipt {\n    byzantium: true;\n    status: number;\n    root: null;\n}\n*/\n/**\n *  A **TransactionReceipt** includes additional information about a\n *  transaction that is only available after it has been mined.\n */\nexport class TransactionReceipt {\n    /**\n     *  The provider connected to the log used to fetch additional details\n     *  if necessary.\n     */\n    provider;\n    /**\n     *  The address the transaction was send to.\n     */\n    to;\n    /**\n     *  The sender of the transaction.\n     */\n    from;\n    /**\n     *  The address of the contract if the transaction was directly\n     *  responsible for deploying one.\n     *\n     *  This is non-null **only** if the ``to`` is empty and the ``data``\n     *  was successfully executed as initcode.\n     */\n    contractAddress;\n    /**\n     *  The transaction hash.\n     */\n    hash;\n    /**\n     *  The index of this transaction within the block transactions.\n     */\n    index;\n    /**\n     *  The block hash of the [[Block]] this transaction was included in.\n     */\n    blockHash;\n    /**\n     *  The block number of the [[Block]] this transaction was included in.\n     */\n    blockNumber;\n    /**\n     *  The bloom filter bytes that represent all logs that occurred within\n     *  this transaction. This is generally not useful for most developers,\n     *  but can be used to validate the included logs.\n     */\n    logsBloom;\n    /**\n     *  The actual amount of gas used by this transaction.\n     *\n     *  When creating a transaction, the amount of gas that will be used can\n     *  only be approximated, but the sender must pay the gas fee for the\n     *  entire gas limit. After the transaction, the difference is refunded.\n     */\n    gasUsed;\n    /**\n     *  The amount of gas used by all transactions within the block for this\n     *  and all transactions with a lower ``index``.\n     *\n     *  This is generally not useful for developers but can be used to\n     *  validate certain aspects of execution.\n     */\n    cumulativeGasUsed;\n    /**\n     *  The actual gas price used during execution.\n     *\n     *  Due to the complexity of [[link-eip-1559]] this value can only\n     *  be caluclated after the transaction has been mined, snce the base\n     *  fee is protocol-enforced.\n     */\n    gasPrice;\n    /**\n     *  The [[link-eip-2718]] transaction type.\n     */\n    type;\n    //readonly byzantium!: boolean;\n    /**\n     *  The status of this transaction, indicating success (i.e. ``1``) or\n     *  a revert (i.e. ``0``).\n     *\n     *  This is available in post-byzantium blocks, but some backends may\n     *  backfill this value.\n     */\n    status;\n    /**\n     *  The root hash of this transaction.\n     *\n     *  This is no present and was only included in pre-byzantium blocks, but\n     *  could be used to validate certain parts of the receipt.\n     */\n    root;\n    #logs;\n    /**\n     *  @_ignore:\n     */\n    constructor(tx, provider) {\n        this.#logs = Object.freeze(tx.logs.map((log) => {\n            return new Log(log, provider);\n        }));\n        let gasPrice = BN_0;\n        if (tx.effectiveGasPrice != null) {\n            gasPrice = tx.effectiveGasPrice;\n        }\n        else if (tx.gasPrice != null) {\n            gasPrice = tx.gasPrice;\n        }\n        defineProperties(this, {\n            provider,\n            to: tx.to,\n            from: tx.from,\n            contractAddress: tx.contractAddress,\n            hash: tx.hash,\n            index: tx.index,\n            blockHash: tx.blockHash,\n            blockNumber: tx.blockNumber,\n            logsBloom: tx.logsBloom,\n            gasUsed: tx.gasUsed,\n            cumulativeGasUsed: tx.cumulativeGasUsed,\n            gasPrice,\n            type: tx.type,\n            //byzantium: tx.byzantium,\n            status: tx.status,\n            root: tx.root\n        });\n    }\n    /**\n     *  The logs for this transaction.\n     */\n    get logs() { return this.#logs; }\n    /**\n     *  Returns a JSON-compatible representation.\n     */\n    toJSON() {\n        const { to, from, contractAddress, hash, index, blockHash, blockNumber, logsBloom, logs, //byzantium, \n        status, root } = this;\n        return {\n            _type: \"TransactionReceipt\",\n            blockHash, blockNumber,\n            //byzantium, \n            contractAddress,\n            cumulativeGasUsed: toJson(this.cumulativeGasUsed),\n            from,\n            gasPrice: toJson(this.gasPrice),\n            gasUsed: toJson(this.gasUsed),\n            hash, index, logs, logsBloom, root, status, to\n        };\n    }\n    /**\n     *  @_ignore:\n     */\n    get length() { return this.logs.length; }\n    [Symbol.iterator]() {\n        let index = 0;\n        return {\n            next: () => {\n                if (index < this.length) {\n                    return { value: this.logs[index++], done: false };\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n    /**\n     *  The total fee for this transaction, in wei.\n     */\n    get fee() {\n        return this.gasUsed * this.gasPrice;\n    }\n    /**\n     *  Resolves to the block this transaction occurred in.\n     */\n    async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to the transaction this transaction occurred in.\n     */\n    async getTransaction() {\n        const tx = await this.provider.getTransaction(this.hash);\n        if (tx == null) {\n            throw new Error(\"TODO\");\n        }\n        return tx;\n    }\n    /**\n     *  Resolves to the return value of the execution of this transaction.\n     *\n     *  Support for this feature is limited, as it requires an archive node\n     *  with the ``debug_`` or ``trace_`` API enabled.\n     */\n    async getResult() {\n        return (await this.provider.getTransactionResult(this.hash));\n    }\n    /**\n     *  Resolves to the number of confirmations this transaction has.\n     */\n    async confirmations() {\n        return (await this.provider.getBlockNumber()) - this.blockNumber + 1;\n    }\n    /**\n     *  @_ignore:\n     */\n    removedEvent() {\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  @_ignore:\n     */\n    reorderedEvent(other) {\n        assert(!other || other.isMined(), \"unmined 'other' transction cannot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"reorderedEvent(other)\" });\n        return createReorderedTransactionFilter(this, other);\n    }\n}\n/**\n *  A **TransactionResponse** includes all properties about a transaction\n *  that was sent to the network, which may or may not be included in a\n *  block.\n *\n *  The [[TransactionResponse-isMined]] can be used to check if the\n *  transaction has been mined as well as type guard that the otherwise\n *  possibly ``null`` properties are defined.\n */\nexport class TransactionResponse {\n    /**\n     *  The provider this is connected to, which will influence how its\n     *  methods will resolve its async inspection methods.\n     */\n    provider;\n    /**\n     *  The block number of the block that this transaction was included in.\n     *\n     *  This is ``null`` for pending transactions.\n     */\n    blockNumber;\n    /**\n     *  The blockHash of the block that this transaction was included in.\n     *\n     *  This is ``null`` for pending transactions.\n     */\n    blockHash;\n    /**\n     *  The index within the block that this transaction resides at.\n     */\n    index;\n    /**\n     *  The transaction hash.\n     */\n    hash;\n    /**\n     *  The [[link-eip-2718]] transaction envelope type. This is\n     *  ``0`` for legacy transactions types.\n     */\n    type;\n    /**\n     *  The receiver of this transaction.\n     *\n     *  If ``null``, then the transaction is an initcode transaction.\n     *  This means the result of executing the [[data]] will be deployed\n     *  as a new contract on chain (assuming it does not revert) and the\n     *  address may be computed using [[getCreateAddress]].\n     */\n    to;\n    /**\n     *  The sender of this transaction. It is implicitly computed\n     *  from the transaction pre-image hash (as the digest) and the\n     *  [[signature]] using ecrecover.\n     */\n    from;\n    /**\n     *  The nonce, which is used to prevent replay attacks and offer\n     *  a method to ensure transactions from a given sender are explicitly\n     *  ordered.\n     *\n     *  When sending a transaction, this must be equal to the number of\n     *  transactions ever sent by [[from]].\n     */\n    nonce;\n    /**\n     *  The maximum units of gas this transaction can consume. If execution\n     *  exceeds this, the entries transaction is reverted and the sender\n     *  is charged for the full amount, despite not state changes being made.\n     */\n    gasLimit;\n    /**\n     *  The gas price can have various values, depending on the network.\n     *\n     *  In modern networks, for transactions that are included this is\n     *  the //effective gas price// (the fee per gas that was actually\n     *  charged), while for transactions that have not been included yet\n     *  is the [[maxFeePerGas]].\n     *\n     *  For legacy transactions, or transactions on legacy networks, this\n     *  is the fee that will be charged per unit of gas the transaction\n     *  consumes.\n     */\n    gasPrice;\n    /**\n     *  The maximum priority fee (per unit of gas) to allow a\n     *  validator to charge the sender. This is inclusive of the\n     *  [[maxFeeFeePerGas]].\n     */\n    maxPriorityFeePerGas;\n    /**\n     *  The maximum fee (per unit of gas) to allow this transaction\n     *  to charge the sender.\n     */\n    maxFeePerGas;\n    /**\n     *  The data.\n     */\n    data;\n    /**\n     *  The value, in wei. Use [[formatEther]] to format this value\n     *  as ether.\n     */\n    value;\n    /**\n     *  The chain ID.\n     */\n    chainId;\n    /**\n     *  The signature.\n     */\n    signature;\n    /**\n     *  The [[link-eip-2930]] access list for transaction types that\n     *  support it, otherwise ``null``.\n     */\n    accessList;\n    #startBlock;\n    /**\n     *  @_ignore:\n     */\n    constructor(tx, provider) {\n        this.provider = provider;\n        this.blockNumber = (tx.blockNumber != null) ? tx.blockNumber : null;\n        this.blockHash = (tx.blockHash != null) ? tx.blockHash : null;\n        this.hash = tx.hash;\n        this.index = tx.index;\n        this.type = tx.type;\n        this.from = tx.from;\n        this.to = tx.to || null;\n        this.gasLimit = tx.gasLimit;\n        this.nonce = tx.nonce;\n        this.data = tx.data;\n        this.value = tx.value;\n        this.gasPrice = tx.gasPrice;\n        this.maxPriorityFeePerGas = (tx.maxPriorityFeePerGas != null) ? tx.maxPriorityFeePerGas : null;\n        this.maxFeePerGas = (tx.maxFeePerGas != null) ? tx.maxFeePerGas : null;\n        this.chainId = tx.chainId;\n        this.signature = tx.signature;\n        this.accessList = (tx.accessList != null) ? tx.accessList : null;\n        this.#startBlock = -1;\n    }\n    /**\n     *  Returns a JSON-compatible representation of this transaction.\n     */\n    toJSON() {\n        const { blockNumber, blockHash, index, hash, type, to, from, nonce, data, signature, accessList } = this;\n        return {\n            _type: \"TransactionReceipt\",\n            accessList, blockNumber, blockHash,\n            chainId: toJson(this.chainId),\n            data, from,\n            gasLimit: toJson(this.gasLimit),\n            gasPrice: toJson(this.gasPrice),\n            hash,\n            maxFeePerGas: toJson(this.maxFeePerGas),\n            maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),\n            nonce, signature, to, index, type,\n            value: toJson(this.value),\n        };\n    }\n    /**\n     *  Resolves to the Block that this transaction was included in.\n     *\n     *  This will return null if the transaction has not been included yet.\n     */\n    async getBlock() {\n        let blockNumber = this.blockNumber;\n        if (blockNumber == null) {\n            const tx = await this.getTransaction();\n            if (tx) {\n                blockNumber = tx.blockNumber;\n            }\n        }\n        if (blockNumber == null) {\n            return null;\n        }\n        const block = this.provider.getBlock(blockNumber);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to this transaction being re-requested from the\n     *  provider. This can be used if you have an unmined transaction\n     *  and wish to get an up-to-date populated instance.\n     */\n    async getTransaction() {\n        return this.provider.getTransaction(this.hash);\n    }\n    /**\n     *  Resolve to the number of confirmations this transaction has.\n     */\n    async confirmations() {\n        if (this.blockNumber == null) {\n            const { tx, blockNumber } = await resolveProperties({\n                tx: this.getTransaction(),\n                blockNumber: this.provider.getBlockNumber()\n            });\n            // Not mined yet...\n            if (tx == null || tx.blockNumber == null) {\n                return 0;\n            }\n            return blockNumber - tx.blockNumber + 1;\n        }\n        const blockNumber = await this.provider.getBlockNumber();\n        return blockNumber - this.blockNumber + 1;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */\n    async wait(_confirms, _timeout) {\n        const confirms = (_confirms == null) ? 1 : _confirms;\n        const timeout = (_timeout == null) ? 0 : _timeout;\n        let startBlock = this.#startBlock;\n        let nextScan = -1;\n        let stopScanning = (startBlock === -1) ? true : false;\n        const checkReplacement = async () => {\n            // Get the current transaction count for this sender\n            if (stopScanning) {\n                return null;\n            }\n            const { blockNumber, nonce } = await resolveProperties({\n                blockNumber: this.provider.getBlockNumber(),\n                nonce: this.provider.getTransactionCount(this.from)\n            });\n            // No transaction or our nonce has not been mined yet; but we\n            // can start scanning later when we do start\n            if (nonce < this.nonce) {\n                startBlock = blockNumber;\n                return;\n            }\n            // We were mined; no replacement\n            if (stopScanning) {\n                return null;\n            }\n            const mined = await this.getTransaction();\n            if (mined && mined.blockNumber != null) {\n                return;\n            }\n            // We were replaced; start scanning for that transaction\n            // Starting to scan; look back a few extra blocks for safety\n            if (nextScan === -1) {\n                nextScan = startBlock - 3;\n                if (nextScan < this.#startBlock) {\n                    nextScan = this.#startBlock;\n                }\n            }\n            while (nextScan <= blockNumber) {\n                // Get the next block to scan\n                if (stopScanning) {\n                    return null;\n                }\n                const block = await this.provider.getBlock(nextScan, true);\n                // This should not happen; but we'll try again shortly\n                if (block == null) {\n                    return;\n                }\n                // We were mined; no replacement\n                for (const hash of block) {\n                    if (hash === this.hash) {\n                        return;\n                    }\n                }\n                // Search for the transaction that replaced us\n                for (let i = 0; i < block.length; i++) {\n                    const tx = await block.getTransaction(i);\n                    if (tx.from === this.from && tx.nonce === this.nonce) {\n                        // Get the receipt\n                        if (stopScanning) {\n                            return null;\n                        }\n                        const receipt = await this.provider.getTransactionReceipt(tx.hash);\n                        // This should not happen; but we'll try again shortly\n                        if (receipt == null) {\n                            return;\n                        }\n                        // We will retry this on the next block (this case could be optimized)\n                        if ((blockNumber - receipt.blockNumber + 1) < confirms) {\n                            return;\n                        }\n                        // The reason we were replaced\n                        let reason = \"replaced\";\n                        if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {\n                            reason = \"repriced\";\n                        }\n                        else if (tx.data === \"0x\" && tx.from === tx.to && tx.value === BN_0) {\n                            reason = \"cancelled\";\n                        }\n                        assert(false, \"transaction was replaced\", \"TRANSACTION_REPLACED\", {\n                            cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                            reason,\n                            replacement: tx.replaceableTransaction(startBlock),\n                            hash: tx.hash,\n                            receipt\n                        });\n                    }\n                }\n                nextScan++;\n            }\n            return;\n        };\n        const checkReceipt = (receipt) => {\n            if (receipt == null || receipt.status !== 0) {\n                return receipt;\n            }\n            assert(false, \"transaction execution reverted\", \"CALL_EXCEPTION\", {\n                action: \"sendTransaction\",\n                data: null, reason: null, invocation: null, revert: null,\n                transaction: {\n                    to: receipt.to,\n                    from: receipt.from,\n                    data: \"\" // @TODO: in v7, split out sendTransaction properties\n                }, receipt\n            });\n        };\n        const receipt = await this.provider.getTransactionReceipt(this.hash);\n        if (confirms === 0) {\n            return checkReceipt(receipt);\n        }\n        if (receipt) {\n            if ((await receipt.confirmations()) >= confirms) {\n                return checkReceipt(receipt);\n            }\n        }\n        else {\n            // Check for a replacement; throws if a replacement was found\n            await checkReplacement();\n            // Allow null only when the confirms is 0\n            if (confirms === 0) {\n                return null;\n            }\n        }\n        const waiter = new Promise((resolve, reject) => {\n            // List of things to cancel when we have a result (one way or the other)\n            const cancellers = [];\n            const cancel = () => { cancellers.forEach((c) => c()); };\n            // On cancel, stop scanning for replacements\n            cancellers.push(() => { stopScanning = true; });\n            // Set up any timeout requested\n            if (timeout > 0) {\n                const timer = setTimeout(() => {\n                    cancel();\n                    reject(makeError(\"wait for transaction timeout\", \"TIMEOUT\"));\n                }, timeout);\n                cancellers.push(() => { clearTimeout(timer); });\n            }\n            const txListener = async (receipt) => {\n                // Done; return it!\n                if ((await receipt.confirmations()) >= confirms) {\n                    cancel();\n                    try {\n                        resolve(checkReceipt(receipt));\n                    }\n                    catch (error) {\n                        reject(error);\n                    }\n                }\n            };\n            cancellers.push(() => { this.provider.off(this.hash, txListener); });\n            this.provider.on(this.hash, txListener);\n            // We support replacement detection; start checking\n            if (startBlock >= 0) {\n                const replaceListener = async () => {\n                    try {\n                        // Check for a replacement; this throws only if one is found\n                        await checkReplacement();\n                    }\n                    catch (error) {\n                        // We were replaced (with enough confirms); re-throw the error\n                        if (isError(error, \"TRANSACTION_REPLACED\")) {\n                            cancel();\n                            reject(error);\n                            return;\n                        }\n                    }\n                    // Rescheudle a check on the next block\n                    if (!stopScanning) {\n                        this.provider.once(\"block\", replaceListener);\n                    }\n                };\n                cancellers.push(() => { this.provider.off(\"block\", replaceListener); });\n                this.provider.once(\"block\", replaceListener);\n            }\n        });\n        return await waiter;\n    }\n    /**\n     *  Returns ``true`` if this transaction has been included.\n     *\n     *  This is effective only as of the time the TransactionResponse\n     *  was instantiated. To get up-to-date information, use\n     *  [[getTransaction]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  non-null property values for properties that are null for\n     *  unmined transactions.\n     */\n    isMined() {\n        return (this.blockHash != null);\n    }\n    /**\n     *  Returns true if the transaction is a legacy (i.e. ``type == 0``)\n     *  transaction.\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isLegacy() {\n        return (this.type === 0);\n    }\n    /**\n     *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)\n     *  transaction. See [[link-eip-2070]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isBerlin() {\n        return (this.type === 1);\n    }\n    /**\n     *  Returns true if the transaction is a London (i.e. ``type == 2``)\n     *  transaction. See [[link-eip-1559]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isLondon() {\n        return (this.type === 2);\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that evict this transaction.\n     */\n    removedEvent() {\n        assert(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that re-order this event against %%other%%.\n     */\n    reorderedEvent(other) {\n        assert(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n        assert(!other || other.isMined(), \"unmined 'other' transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n        return createReorderedTransactionFilter(this, other);\n    }\n    /**\n     *  Returns a new TransactionResponse instance which has the ability to\n     *  detect (and throw an error) if the transaction is replaced, which\n     *  will begin scanning at %%startBlock%%.\n     *\n     *  This should generally not be used by developers and is intended\n     *  primarily for internal use. Setting an incorrect %%startBlock%% can\n     *  have devastating performance consequences if used incorrectly.\n     */\n    replaceableTransaction(startBlock) {\n        assertArgument(Number.isInteger(startBlock) && startBlock >= 0, \"invalid startBlock\", \"startBlock\", startBlock);\n        const tx = new TransactionResponse(this, this.provider);\n        tx.#startBlock = startBlock;\n        return tx;\n    }\n}\nfunction createOrphanedBlockFilter(block) {\n    return { orphan: \"drop-block\", hash: block.hash, number: block.number };\n}\nfunction createReorderedTransactionFilter(tx, other) {\n    return { orphan: \"reorder-transaction\", tx, other };\n}\nfunction createRemovedTransactionFilter(tx) {\n    return { orphan: \"drop-transaction\", tx };\n}\nfunction createRemovedLogFilter(log) {\n    return { orphan: \"drop-log\", log: {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            address: log.address,\n            data: log.data,\n            topics: Object.freeze(log.topics.slice()),\n            index: log.index\n        } };\n}\n//# sourceMappingURL=provider.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}