{"ast":null,"code":"function hex2rgba(hex) {\n  if (typeof hex !== 'string') {\n    throw new Error('Color should be defined as hex string');\n  }\n  var hexCode = hex.slice().replace('#', '').split('');\n  if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {\n    throw new Error('Invalid hex color: ' + hex);\n  }\n\n  // Convert from short to long form (fff -> ffffff)\n  if (hexCode.length === 3 || hexCode.length === 4) {\n    hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {\n      return [c, c];\n    }));\n  }\n\n  // Add default alpha value\n  if (hexCode.length === 6) hexCode.push('F', 'F');\n  var hexValue = parseInt(hexCode.join(''), 16);\n  return {\n    r: hexValue >> 24 & 255,\n    g: hexValue >> 16 & 255,\n    b: hexValue >> 8 & 255,\n    a: hexValue & 255\n  };\n}\nexports.getOptions = function getOptions(options) {\n  if (!options) options = {};\n  if (!options.color) options.color = {};\n  var margin = typeof options.margin === 'undefined' || options.margin === null || options.margin < 0 ? 4 : options.margin;\n  return {\n    scale: options.scale || 4,\n    margin: margin,\n    color: {\n      dark: hex2rgba(options.color.dark || '#000000ff'),\n      light: hex2rgba(options.color.light || '#ffffffff')\n    },\n    type: options.type,\n    rendererOpts: options.rendererOpts || {}\n  };\n};\nexports.qrToImageData = function qrToImageData(imgData, qr, margin, scale, color) {\n  var size = qr.modules.size;\n  var data = qr.modules.data;\n  var scaledMargin = margin * scale;\n  var symbolSize = size * scale + scaledMargin * 2;\n  var palette = [color.light, color.dark];\n  for (var i = 0; i < symbolSize; i++) {\n    for (var j = 0; j < symbolSize; j++) {\n      var posDst = (i * symbolSize + j) * 4;\n      var pxColor = color.light;\n      if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {\n        var iSrc = Math.floor((i - scaledMargin) / scale);\n        var jSrc = Math.floor((j - scaledMargin) / scale);\n        pxColor = palette[data[iSrc * size + jSrc]];\n      }\n      imgData[posDst++] = pxColor.r;\n      imgData[posDst++] = pxColor.g;\n      imgData[posDst++] = pxColor.b;\n      imgData[posDst] = pxColor.a;\n    }\n  }\n};","map":{"version":3,"names":["hex2rgba","hex","Error","hexCode","slice","replace","split","length","Array","prototype","concat","apply","map","c","push","hexValue","parseInt","join","r","g","b","a","exports","getOptions","options","color","margin","scale","dark","light","type","rendererOpts","qrToImageData","imgData","qr","size","modules","data","scaledMargin","symbolSize","palette","i","j","posDst","pxColor","iSrc","Math","floor","jSrc"],"sources":["C:/Users/alero/node_modules/qrcode/lib/renderer/utils.js"],"sourcesContent":["function hex2rgba (hex) {\n  if (typeof hex !== 'string') {\n    throw new Error('Color should be defined as hex string')\n  }\n\n  var hexCode = hex.slice().replace('#', '').split('')\n  if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {\n    throw new Error('Invalid hex color: ' + hex)\n  }\n\n  // Convert from short to long form (fff -> ffffff)\n  if (hexCode.length === 3 || hexCode.length === 4) {\n    hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {\n      return [c, c]\n    }))\n  }\n\n  // Add default alpha value\n  if (hexCode.length === 6) hexCode.push('F', 'F')\n\n  var hexValue = parseInt(hexCode.join(''), 16)\n\n  return {\n    r: (hexValue >> 24) & 255,\n    g: (hexValue >> 16) & 255,\n    b: (hexValue >> 8) & 255,\n    a: hexValue & 255\n  }\n}\n\nexports.getOptions = function getOptions (options) {\n  if (!options) options = {}\n  if (!options.color) options.color = {}\n\n  var margin = typeof options.margin === 'undefined' ||\n    options.margin === null ||\n    options.margin < 0 ? 4 : options.margin\n\n  return {\n    scale: options.scale || 4,\n    margin: margin,\n    color: {\n      dark: hex2rgba(options.color.dark || '#000000ff'),\n      light: hex2rgba(options.color.light || '#ffffffff')\n    },\n    type: options.type,\n    rendererOpts: options.rendererOpts || {}\n  }\n}\n\nexports.qrToImageData = function qrToImageData (imgData, qr, margin, scale, color) {\n  var size = qr.modules.size\n  var data = qr.modules.data\n  var scaledMargin = margin * scale\n  var symbolSize = size * scale + scaledMargin * 2\n  var palette = [color.light, color.dark]\n\n  for (var i = 0; i < symbolSize; i++) {\n    for (var j = 0; j < symbolSize; j++) {\n      var posDst = (i * symbolSize + j) * 4\n      var pxColor = color.light\n\n      if (i >= scaledMargin && j >= scaledMargin &&\n        i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {\n        var iSrc = Math.floor((i - scaledMargin) / scale)\n        var jSrc = Math.floor((j - scaledMargin) / scale)\n        pxColor = palette[data[iSrc * size + jSrc]]\n      }\n\n      imgData[posDst++] = pxColor.r\n      imgData[posDst++] = pxColor.g\n      imgData[posDst++] = pxColor.b\n      imgData[posDst] = pxColor.a\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}